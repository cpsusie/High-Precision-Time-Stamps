<?xml version="1.0"?>
<doc>
    <assembly>
        <name>HighPrecisionTimeStamps</name>
    </assembly>
    <members>
        <member name="T:HpTimeStamps.BigMath.Int128">
            <summary>
                Represents a 128-bit signed integer.
            </summary>
        </member>
        <member name="F:HpTimeStamps.BigMath.Int128.Zero">
            <summary>
                Gets a value that represents the number 0 (zero).
            </summary>
        </member>
        <member name="F:HpTimeStamps.BigMath.Int128.MaxValue">
            <summary>
                Represents the largest possible value of an Int128.
            </summary>
        </member>
        <member name="F:HpTimeStamps.BigMath.Int128.MinValue">
            <summary>
                Represents the smallest possible value of an Int128.
            </summary>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.Byte)">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.Boolean)">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="value">if set to <c>true</c> [value].</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.Char)">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.Decimal)">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.Double)">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.Single)">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.Int16)">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.Int64)">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.SByte)">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.UInt16)">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.UInt32)">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.UInt64)">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.Guid)">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.#ctor(System.Int32,System.ReadOnlySpan{System.UInt32})">
            <summary>
                Initializes a new instance of the <see cref="T:HpTimeStamps.BigMath.Int128" /> struct.
            </summary>
            <param name="sign">The sign.</param>
            <param name="intsIncoming">The ints.</param>
        </member>
        <member name="P:HpTimeStamps.BigMath.Int128.HighSigned">
            <summary>
            Higher 64 bits expressed as signed integer
            </summary>
        </member>
        <member name="P:HpTimeStamps.BigMath.Int128.High">
            <summary>
                Higher 64 bits (unsigned).
            </summary>
        </member>
        <member name="P:HpTimeStamps.BigMath.Int128.Low">
            <summary>
                Lower 64 bits.
            </summary>
        </member>
        <member name="P:HpTimeStamps.BigMath.Int128.Sign">
            <summary>
                Gets a number that indicates the sign (negative, positive, or zero) of the current Int128 object.
            </summary>
            <value>A number that indicates the sign of the Int128 object</value>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.GetHashCode">
            <summary>
                Returns a hash code for this instance.
            </summary>
            <returns>
                A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.Equals(System.Object)">
            <summary>
                Returns a value indicating whether this instance is equal to a specified object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns>
                true if obj has the same value as this instance; otherwise, false.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.Equals(HpTimeStamps.BigMath.Int128)">
            <summary>
                Returns a value indicating whether this instance is equal to a specified Int64 value.
            </summary>
            <param name="obj">The obj.</param>
            <returns>
                true if obj has the same value as this instance; otherwise, false.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.ToString">
            <summary>
                Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
                A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.UnsignedAbsoluteValue">
            <summary>
            Get the absolute value of this value as an unsigned integer.  If this value is negative,
            after casting to unsigned the value will be returned in its 2's complement form
            </summary>
            <returns>The absolute value as an unsigned integer</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.ToString(System.String,System.IFormatProvider)">
            <summary>
                Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <param name="format">The format. Only x, X, g, G, d, D are supported.</param>
            <param name="formatProvider">An object that supplies culture-specific formatting information about this instance.</param>
            <returns>
                A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.TryConvert(System.Type,System.IFormatProvider,System.Boolean,System.Object@)">
            <summary>
                Converts the numeric value to an equivalent object. The return value indicates whether the conversion succeeded.
            </summary>
            <param name="conversionType">The target conversion type.</param>
            <param name="provider">An object that supplies culture-specific information about the conversion.</param>
            <param name="asLittleEndian">As little endian.</param>
            <param name="value">
                When this method returns, contains the value that is equivalent to the numeric value, if the
                conversion succeeded, or is null if the conversion failed. This parameter is passed uninitialized.
            </param>
            <returns>true if this value was converted successfully; otherwise, false.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.Parse(System.String)">
            <summary>
                Converts the string representation of a number to its Int128 equivalent.
            </summary>
            <param name="value">A string that contains a number to convert.</param>
            <returns>
                A value that is equivalent to the number specified in the value parameter.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.Parse(System.String,System.Globalization.NumberStyles)">
            <summary>
                Converts the string representation of a number in a specified style format to its Int128 equivalent.
            </summary>
            <param name="value">A string that contains a number to convert.</param>
            <param name="style">A bitwise combination of the enumeration values that specify the permitted format of value.</param>
            <returns>
                A value that is equivalent to the number specified in the value parameter.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.Parse(System.String,System.IFormatProvider)">
            <summary>
                Converts the string representation of a number in a culture-specific format to its Int128 equivalent.
            </summary>
            <param name="value">A string that contains a number to convert.</param>
            <param name="provider">An object that provides culture-specific formatting information about value.</param>
            <returns>
                A value that is equivalent to the number specified in the value parameter.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
                Converts the string representation of a number in a specified style and culture-specific format to its Int128
                equivalent.
            </summary>
            <param name="value">A string that contains a number to convert.</param>
            <param name="style">A bitwise combination of the enumeration values that specify the permitted format of value.</param>
            <param name="provider">An object that provides culture-specific formatting information about value.</param>
            <returns>A value that is equivalent to the number specified in the value parameter.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.TryParse(System.String,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Tries to convert the string representation of a number to its Int128 equivalent, and returns a value that indicates
                whether the conversion succeeded..
            </summary>
            <param name="value">The string representation of a number.</param>
            <param name="result">
                When this method returns, contains the Int128 equivalent to the number that is contained in value,
                or Int128.Zero if the conversion failed. This parameter is passed uninitialized.
            </param>
            <returns>
                true if the value parameter was converted successfully; otherwise, false.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Tries to convert the string representation of a number in a specified style and culture-specific format to its
                Int128 equivalent, and returns a value that indicates whether the conversion succeeded..
            </summary>
            <param name="value">
                The string representation of a number. The string is interpreted using the style specified by
                style.
            </param>
            <param name="style">
                A bitwise combination of enumeration values that indicates the style elements that can be present
                in value. A typical value to specify is NumberStyles.Integer.
            </param>
            <param name="provider">An object that supplies culture-specific formatting information about value.</param>
            <param name="result">
                When this method returns, contains the Int128 equivalent to the number that is contained in value,
                or Int128.Zero if the conversion failed. This parameter is passed uninitialized.
            </param>
            <returns>true if the value parameter was converted successfully; otherwise, false.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.ToType(System.Type,System.IFormatProvider,System.Boolean)">
            <summary>
                Converts the value of this instance to an <see cref="T:System.Object" /> of the specified
                <see cref="T:System.Type" /> that has an equivalent value, using the specified culture-specific formatting
                information.
            </summary>
            <param name="conversionType">The <see cref="T:System.Type" /> to which the value of this instance is converted.</param>
            <param name="provider">
                An <see cref="T:System.IFormatProvider" /> interface implementation that supplies
                culture-specific formatting information.
            </param>
            <param name="asLittleEndian">As little endian.</param>
            <returns>
                An <see cref="T:System.Object" /> instance of type <paramref name="conversionType" /> whose value is equivalent to
                the value of this instance.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.System#IComparable#CompareTo(System.Object)">
            <summary>
                Compares the current instance with another object of the same type and returns an integer that indicates whether
                the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
            </summary>
            <param name="obj">An object to compare with this instance.</param>
            <returns>
                A value that indicates the relative order of the objects being compared. The return value has these meanings: Value
                Meaning Less than zero This instance is less than <paramref name="obj" />. Zero This instance is equal to
                <paramref name="obj" />. Greater than zero This instance is greater than <paramref name="obj" />.
            </returns>
            <exception cref="T:System.ArgumentException">
                <paramref name="obj" /> is not the same type as this instance.
            </exception>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.Compare(HpTimeStamps.BigMath.Int128@,System.Object)">
            <summary>
                Compares two Int128 values and returns an integer that indicates whether the first value is less than, equal to, or
                greater than the second value.
            </summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>A signed integer that indicates the relative values of left and right, as shown in the following table.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.Compare(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Compares two 128-bit signed integer values and returns an integer that indicates whether the first value is less
                than, equal to, or greater than the second value.
            </summary>
            <param name="left">The first value to compare.</param>
            <param name="right">The second value to compare.</param>
            <returns>
                A signed number indicating the relative values of this instance and value.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.CompareTo(HpTimeStamps.BigMath.Int128)">
            <summary>
                Compares this instance to a specified 128-bit signed integer and returns an indication of their relative values.
            </summary>
            <param name="value">An integer to compare.</param>
            <returns>A signed number indicating the relative values of this instance and value.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.TwosComplementNegate(HpTimeStamps.BigMath.Int128)">
            <summary>
                Negates a specified Int128 value.
            </summary>
            <param name="value">The value to negate.</param>
            <returns>The result of the value parameter multiplied by negative one (-1).</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.ToAbs">
            <summary>
                Gets the absolute value this object.
            </summary>
            <returns>The absolute value.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.Abs(HpTimeStamps.BigMath.Int128@)">
            <summary>
                Gets the absolute value of an Int128 object.
            </summary>
            <param name="value">A number.</param>
            <returns>
                The absolute value.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.DivRem(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Divides one Int128 value by another, returns the result, and returns the remainder in an output parameter.
            </summary>
            <param name="dividend">The value to be divided.</param>
            <param name="divisor">The value to divide by.</param>
            <returns>
                The quotient of the division.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.ToUIn64Array">
            <summary>
                Converts an Int128 value to an unsigned long array.
            </summary>
            <returns>
                The value of the current Int128 object converted to an array of unsigned integers.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.ToUIn32Array">
            <summary>
                Converts an Int128 value to an unsigned integer array.
            </summary>
            <returns>The value of the current Int128 object converted to an array of unsigned integers.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.SlowMultiply(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Returns the product of two Int128 values.
            </summary>
            <param name="left">The first number to multiply.</param>
            <param name="right">The second number to multiply.</param>
            <returns>The product of the left and right parameters.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Implicit(System.Boolean)~HpTimeStamps.BigMath.Int128">
            <summary>
                Performs an implicit conversion from <see cref="T:System.Boolean" /> to <see cref="T:HpTimeStamps.BigMath.Int128" />.
            </summary>
            <param name="value">if set to <c>true</c> [value].</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Implicit(System.Byte)~HpTimeStamps.BigMath.Int128">
            <summary>
                Performs an implicit conversion from <see cref="T:System.Byte" /> to <see cref="T:HpTimeStamps.BigMath.Int128" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Implicit(System.Char)~HpTimeStamps.BigMath.Int128">
            <summary>
                Performs an implicit conversion from <see cref="T:System.Char" /> to <see cref="T:HpTimeStamps.BigMath.Int128" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(System.Decimal)~HpTimeStamps.BigMath.Int128">
            <summary>
                Performs an explicit conversion from <see cref="T:System.Decimal" /> to <see cref="T:HpTimeStamps.BigMath.Int128" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(System.Double)~HpTimeStamps.BigMath.Int128">
            <summary>
                Performs an explicit conversion from <see cref="T:System.Double" /> to <see cref="T:HpTimeStamps.BigMath.Int128" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Implicit(System.Int16)~HpTimeStamps.BigMath.Int128">
            <summary>
                Performs an implicit conversion from <see cref="T:System.Int16" /> to <see cref="T:HpTimeStamps.BigMath.Int128" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Implicit(System.Int32)~HpTimeStamps.BigMath.Int128">
            <summary>
                Performs an implicit conversion from <see cref="T:System.Int32" /> to <see cref="T:HpTimeStamps.BigMath.Int128" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Implicit(System.Int64)~HpTimeStamps.BigMath.Int128">
            <summary>
                Performs an implicit conversion from <see cref="T:System.Int64" /> to <see cref="T:HpTimeStamps.BigMath.Int128" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Implicit(System.SByte)~HpTimeStamps.BigMath.Int128">
            <summary>
                Performs an implicit conversion from <see cref="T:System.SByte" /> to <see cref="T:HpTimeStamps.BigMath.Int128" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(System.Single)~HpTimeStamps.BigMath.Int128">
            <summary>
                Performs an explicit conversion from <see cref="T:System.Single" /> to <see cref="T:HpTimeStamps.BigMath.Int128" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Implicit(System.UInt16)~HpTimeStamps.BigMath.Int128">
            <summary>
                Performs an implicit conversion from <see cref="T:System.UInt16" /> to <see cref="T:HpTimeStamps.BigMath.Int128" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Implicit(System.UInt32)~HpTimeStamps.BigMath.Int128">
            <summary>
                Performs an implicit conversion from <see cref="T:System.UInt32" /> to <see cref="T:HpTimeStamps.BigMath.Int128" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Implicit(System.UInt64)~HpTimeStamps.BigMath.Int128">
            <summary>
                Performs an implicit conversion from <see cref="T:System.UInt64" /> to <see cref="T:HpTimeStamps.BigMath.Int128" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(HpTimeStamps.BigMath.Int128)~System.Boolean">
            <summary>
                Performs an explicit conversion from <see cref="T:HpTimeStamps.BigMath.Int128" /> to <see cref="T:System.Boolean" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(HpTimeStamps.BigMath.Int128@)~System.Byte">
            <summary>
                Performs an explicit conversion from <see cref="T:HpTimeStamps.BigMath.Int128" /> to <see cref="T:System.Byte" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(HpTimeStamps.BigMath.Int128@)~System.Char">
            <summary>
                Performs an explicit conversion from <see cref="T:HpTimeStamps.BigMath.Int128" /> to <see cref="T:System.Char" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(HpTimeStamps.BigMath.Int128@)~System.Decimal">
            <summary>
                Performs an explicit conversion from <see cref="T:HpTimeStamps.BigMath.Int128" /> to <see cref="T:System.Decimal" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(HpTimeStamps.BigMath.Int128@)~System.Double">
            <summary>
                Performs an explicit conversion from <see cref="T:HpTimeStamps.BigMath.Int128" /> to <see cref="T:System.Double" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(HpTimeStamps.BigMath.Int128@)~System.Single">
            <summary>
                Performs an explicit conversion from <see cref="T:HpTimeStamps.BigMath.Int128" /> to <see cref="T:System.Single" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(HpTimeStamps.BigMath.Int128@)~System.Int16">
            <summary>
                Performs an explicit conversion from <see cref="T:HpTimeStamps.BigMath.Int128" /> to <see cref="T:System.Int16" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(HpTimeStamps.BigMath.Int128@)~System.Int32">
            <summary>
                Performs an explicit conversion from <see cref="T:HpTimeStamps.BigMath.Int128" /> to <see cref="T:System.Int32" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(HpTimeStamps.BigMath.Int128@)~System.Int64">
            <summary>
                Performs an explicit conversion from <see cref="T:HpTimeStamps.BigMath.Int128" /> to <see cref="T:System.Int64" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(HpTimeStamps.BigMath.Int128@)~System.UInt32">
            <summary>
                Performs an explicit conversion from <see cref="T:HpTimeStamps.BigMath.Int128" /> to <see cref="T:System.UInt32" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(HpTimeStamps.BigMath.Int128@)~System.UInt16">
            <summary>
                Performs an explicit conversion from <see cref="T:HpTimeStamps.BigMath.Int128" /> to <see cref="T:System.UInt16" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Explicit(HpTimeStamps.BigMath.Int128@)~System.UInt64">
            <summary>
                Performs an explicit conversion from <see cref="T:HpTimeStamps.BigMath.Int128" /> to <see cref="T:System.UInt64" />.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the conversion.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_GreaterThan(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Implements the operator &gt;.
            </summary>
            <param name="left">The x.</param>
            <param name="right">The y.</param>
            <returns>
                The result of the operator.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_LessThan(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Implements the operator &lt;.
            </summary>
            <param name="left">The x.</param>
            <param name="right">The y.</param>
            <returns>
                The result of the operator.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_GreaterThanOrEqual(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Implements the operator &gt;=.
            </summary>
            <param name="left">The x.</param>
            <param name="right">The y.</param>
            <returns>
                The result of the operator.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_LessThanOrEqual(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Implements the operator &lt;=.
            </summary>
            <param name="left">The x.</param>
            <param name="right">The y.</param>
            <returns>
                The result of the operator.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Inequality(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Implements the operator !=.
            </summary>
            <param name="left">The x.</param>
            <param name="right">The y.</param>
            <returns>
                The result of the operator.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Equality(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Implements the operator ==.
            </summary>
            <param name="left">The x.</param>
            <param name="right">The y.</param>
            <returns>
                The result of the operator.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_UnaryPlus(HpTimeStamps.BigMath.Int128@)">
            <summary>
                Implements the operator +.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the operator.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_UnaryNegation(HpTimeStamps.BigMath.Int128@)">
            <summary>
                Implements the operator -.
            </summary>
            <param name="value">The value.</param>
            <returns>
                The result of the operator.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Addition(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Implements the operator +.
            </summary>
            <param name="left">The x.</param>
            <param name="right">The y.</param>
            <returns>
                The result of the operator.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Subtraction(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Implements the operator -.
            </summary>
            <param name="left">The x.</param>
            <param name="right">The y.</param>
            <returns>
                The result of the operator.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Multiply(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Implements the operator *.
            </summary>
            <param name="left">The x.</param>
            <param name="right">The y.</param>
            <returns>
                The result of the operator.
            </returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_RightShift(HpTimeStamps.BigMath.Int128@,System.Int32)">
            <summary>
                Implements the operator &gt;&gt;.
            </summary>
            <param name="lhs">The value.</param>
            <param name="amount">The shift.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_LeftShift(HpTimeStamps.BigMath.Int128@,System.Int32)">
            <summary>
                Implements the operator &lt;&lt;.
            </summary>
            <param name="value">The value.</param>
            <param name="amount">The shift.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_ExclusiveOr(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
            XOR bitwise operator
            </summary>
            <param name="left">left hand operand</param>
            <param name="right">right hand operand</param>
            <returns>value that is <paramref name="left"/> bitwise-xor'd
            with <paramref name="right"/>.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_BitwiseOr(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Implements the operator |.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_BitwiseAnd(HpTimeStamps.BigMath.Int128@,HpTimeStamps.BigMath.Int128@)">
            <summary>
                Implements the operator &amp;.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_OnesComplement(HpTimeStamps.BigMath.Int128@)">
            <summary>
                Implements the operator ~.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Increment(HpTimeStamps.BigMath.Int128)">
            <summary>
                Implements the operator ++.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Int128.op_Decrement(HpTimeStamps.BigMath.Int128)">
            <summary>
                Implements the operator --.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="T:HpTimeStamps.BigMath.Utils.ArrayUtils">
            <summary>
                Utils for the <see cref="T:System.Array" /> class.
            </summary>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ArrayUtils.ConvertAll``2(``0[],System.Func{``0,``1})">
            <summary>
                Converts an array of one type to an array of another type.
            </summary>
            <returns>
                An array of the target type containing the converted elements from the source array.
            </returns>
            <param name="array">The one-dimensional, zero-based <see cref="T:System.Array" /> to convert to a target type.</param>
            <param name="convert">A <see cref="T:System.Func`2" /> that converts each element from one type to another type.</param>
            <typeparam name="TInput">The type of the elements of the source array.</typeparam>
            <typeparam name="TOutput">The type of the elements of the target array.</typeparam>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="array" /> is null.-or-<paramref name="convert" /> is
                null.
            </exception>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ArrayUtils.GetNonZeroLength(System.Byte[],System.Nullable{System.Boolean})">
            <summary>
                Get length of serial non zero items.
            </summary>
            <param name="bytes">Array of bytes.</param>
            <param name="asLittleEndian">True - skip all zero items from high. False - skip all zero items from low.</param>
            <returns>Length of serial non zero items.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ArrayUtils.TrimZeros(System.Byte[],System.Nullable{System.Boolean})">
            <summary>
                Trim zero items.
            </summary>
            <param name="bytes">Array of bytes.</param>
            <param name="asLittleEndian">True - trim from high, False - trim from low.</param>
            <returns>Trimmed array of bytes.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ArrayUtils.ToHexString(System.Byte[],System.Boolean,System.Int32,System.Boolean,System.Boolean)">
            <summary>
                Converts array of bytes to hexadecimal string.
            </summary>
            <param name="bytes">Bytes.</param>
            <param name="caps">Capitalize chars.</param>
            <param name="min">Minimum string length. 0 if there is no minimum length.</param>
            <param name="spaceEveryByte">Space every byte.</param>
            <param name="trimZeros">Trim zeros in the result string.</param>
            <returns>Hexadecimal string representation of the bytes array.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ArrayUtils.ToHexString(System.ArraySegment{System.Byte},System.Boolean,System.Int32,System.Boolean,System.Boolean)">
            <summary>
                Converts array of bytes to hexadecimal string.
            </summary>
            <param name="bytes">Bytes.</param>
            <param name="caps">Capitalize chars.</param>
            <param name="min">Minimum string length. 0 if there is no minimum length.</param>
            <param name="spaceEveryByte">Space every byte.</param>
            <param name="trimZeros">Trim zeros in the result string.</param>
            <returns>Hexadecimal string representation of the bytes array.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ArrayUtils.HexToBytes(System.String)">
            <summary>
                Converts string of hex numbers to array of bytes.
            </summary>
            <param name="hexString">String value.</param>
            <returns>Array of bytes.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.CjmUtils.Fls128(HpTimeStamps.BigMath.Int128@)">
            <summary>
            Return the bitpos of the most significant set bit (i.e. with value == 1).
            Adapted from Abseil.IO's ABSL_ATTRIBUTE_ALWAYS_INLINE int Fls128(uint128 n) function found at
            https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/numeric/int128.cc .
            Unlike <see cref="M:HpTimeStamps.BigMath.Utils.CjmUtils.CountLeadingZeros(System.UInt64)"/> which I have absolutely no idea how it works, this seems pretty
            straight forward ... except insofar as it relies on the WTFishness of <see cref="M:HpTimeStamps.BigMath.Utils.CjmUtils.CountLeadingZeros(System.UInt64)"/>.
            </summary>
            <param name="testMe">the value to test</param>
            <returns>the bitpos of the most significant bit whose value is one (0 to 127).</returns>
            <remarks>DO NOT SEND THIS FUNCTION ZERO AS A VALUE!</remarks>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.CjmUtils.Fls128(HpTimeStamps.BigMath.UInt128@)">
            <summary>
            Return the bitpos of the most significant set bit (i.e. with value == 1).
            Adapted from Abseil.IO's ABSL_ATTRIBUTE_ALWAYS_INLINE int Fls128(uint128 n) function found at
            https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/numeric/int128.cc .
            Unlike <see cref="M:HpTimeStamps.BigMath.Utils.CjmUtils.CountLeadingZeros(System.UInt64)"/> which I have absolutely no idea how it works, this seems pretty
            straight forward ... except insofar as it relies on the WTFishness of <see cref="M:HpTimeStamps.BigMath.Utils.CjmUtils.CountLeadingZeros(System.UInt64)"/>.
            </summary>
            <param name="testMe">the value to test</param>
            <returns>the bitpos of the most significant bit whose value is one (0 to 127).</returns>
            <remarks>DO NOT SEND THIS FUNCTION ZERO AS A VALUE!</remarks>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.CjmUtils.CountLeadingZeros(System.UInt64)">
            <summary>
            I have no idea how or why this works ... I adapted it from abseil.io's
            function ABSL_BASE_INTERNAL_FORCEINLINE int CountLeadingZeros64Slow(uint64_t n) at
            https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/base/internal/bits.h.
            It comes from google d00dz and passes unit testing, so I'm calling it good.
            </summary>
            <param name="n">the ulong you want to get the leading zero count for.</param>
            <returns>the leading zero count</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Zero is not a permissible value.</exception>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.CjmUtils.UnsignedShiftRight(HpTimeStamps.BigMath.Int128@,System.Int32)">
            <summary>
            Taken from abseil.io's uint128 operator>>(uint128 lhs, int amount)
            at <see link="https://raw.githubusercontent.com/abseil/abseil-cpp/master/absl/numeric/int128.h"/>
            </summary>
            <param name="shiftUs">value to shift</param>
            <param name="amount">amount to shift</param>
            <returns>the amount shifted right as if it were unsigned</returns>
        </member>
        <member name="T:HpTimeStamps.BigMath.Utils.Crc32">
            <summary>
                Crc32 calculator.
            </summary>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.Crc32.Init">
            <summary>
                Reset CRC.
            </summary>
        </member>
        <member name="T:HpTimeStamps.BigMath.Utils.ExtendedBitConverter">
            <summary>
                Bit converter methods which support explicit endian.
            </summary>
        </member>
        <member name="F:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.IsLittleEndian">
            <summary>
                Indicates the byte order ("endianness") in which data is stored in this computer architecture.
            </summary>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToBytes(System.Int16,System.Nullable{System.Boolean})">
            <summary>
                Converts <see cref="T:System.Int16" /> to array of bytes.
            </summary>
            <param name="value">Value.</param>
            <param name="asLittleEndian">Convert to little endian.</param>
            <returns>Array of bytes.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToBytes(System.Int16,System.Byte[],System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts <see cref="T:System.Int16" /> to array of bytes.
            </summary>
            <param name="value">Value.</param>
            <param name="buffer">Buffer at least 2 bytes.</param>
            <param name="offset">The starting position within <paramref name="buffer" />.</param>
            <param name="asLittleEndian">Convert to little endian.</param>
            <returns>Array of bytes.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToInt16(System.Byte[],System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts array of bytes to <see cref="T:System.Int16" />.
            </summary>
            <param name="bytes">An array of bytes.</param>
            <param name="offset">The starting position within <paramref name="bytes" />.</param>
            <param name="asLittleEndian">Convert from little endian.</param>
            <returns><see cref="T:System.Int16" /> value.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToBytes(System.UInt16,System.Nullable{System.Boolean})">
            <summary>
                Converts <see cref="T:System.UInt16" /> to array of bytes.
            </summary>
            <param name="value">Value.</param>
            <param name="asLittleEndian">Convert to little endian.</param>
            <returns>Array of bytes.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToBytes(System.UInt16,System.Byte[],System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts <see cref="T:System.UInt16" /> to array of bytes.
            </summary>
            <param name="value">Value.</param>
            <param name="buffer">Buffer at least 2 bytes.</param>
            <param name="offset">The starting position within <paramref name="buffer" />.</param>
            <param name="asLittleEndian">Convert to little endian.</param>
            <returns>Array of bytes.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToUInt16(System.Byte[],System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts array of bytes to <see cref="T:System.UInt16" />.
            </summary>
            <param name="bytes">An array of bytes.</param>
            <param name="offset">The starting position within <paramref name="bytes" />.</param>
            <param name="asLittleEndian">Convert from little endian.</param>
            <returns><see cref="T:System.UInt16" /> value.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToBytes(System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts <see cref="T:System.Int32" /> to array of bytes.
            </summary>
            <param name="value">Value.</param>
            <param name="asLittleEndian">Convert to little endian.</param>
            <returns>Array of bytes.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToBytes(System.Int32,System.Byte[],System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts <see cref="T:System.Int32" /> to array of bytes.
            </summary>
            <param name="value">Value.</param>
            <param name="buffer">Buffer at least 4 bytes.</param>
            <param name="offset">The starting position within <paramref name="buffer" />.</param>
            <param name="asLittleEndian">Convert to little endian.</param>
            <returns>Array of bytes.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToInt32(System.Byte[],System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts array of bytes to <see cref="T:System.Int32" />.
            </summary>
            <param name="bytes">An array of bytes.</param>
            <param name="offset">The starting position within <paramref name="bytes" />.</param>
            <param name="asLittleEndian">Convert from little endian.</param>
            <returns><see cref="T:System.Int32" /> value.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToBytes(System.UInt32,System.Nullable{System.Boolean})">
            <summary>
                Converts <see cref="T:System.UInt32" /> to array of bytes.
            </summary>
            <param name="value">Value.</param>
            <param name="asLittleEndian">Convert to little endian.</param>
            <returns>Array of bytes.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToBytes(System.UInt32,System.Byte[],System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts <see cref="T:System.UInt32" /> to array of bytes.
            </summary>
            <param name="value">Value.</param>
            <param name="buffer">Buffer at least 4 bytes.</param>
            <param name="offset">The starting position within <paramref name="buffer" />.</param>
            <param name="asLittleEndian">Convert to little endian.</param>
            <returns>Array of bytes.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToUInt32(System.Byte[],System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts array of bytes to <see cref="T:System.UInt32" />.
            </summary>
            <param name="bytes">An array of bytes.</param>
            <param name="offset">The starting position within <paramref name="bytes" />.</param>
            <param name="asLittleEndian">Convert from little endian.</param>
            <returns><see cref="T:System.UInt32" /> value.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToBytes(System.Int64,System.Nullable{System.Boolean})">
            <summary>
                Converts <see cref="T:System.Int64" /> to array of bytes.
            </summary>
            <param name="value">Value.</param>
            <param name="asLittleEndian">Convert to little endian.</param>
            <returns>Array of bytes.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToBytes(System.Int64,System.Byte[],System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts <see cref="T:System.Int64" /> to array of bytes.
            </summary>
            <param name="value">Value.</param>
            <param name="buffer">Buffer at least 8 bytes.</param>
            <param name="offset">The starting position within <paramref name="buffer" />.</param>
            <param name="asLittleEndian">Convert to little endian.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToInt64(System.Byte[],System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts array of bytes to <see cref="T:System.Int64" />.
            </summary>
            <param name="bytes">An array of bytes. </param>
            <param name="offset">The starting position within <paramref name="bytes" />.</param>
            <param name="asLittleEndian">Convert from little endian.</param>
            <returns><see cref="T:System.Int64" /> value.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToBytes(System.UInt64,System.Nullable{System.Boolean})">
            <summary>
                Converts <see cref="T:System.UInt64" /> to array of bytes.
            </summary>
            <param name="value">Value.</param>
            <param name="asLittleEndian">Convert to little endian.</param>
            <returns>Array of bytes.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToBytes(System.UInt64,System.Byte[],System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts <see cref="T:System.UInt64" /> to array of bytes.
            </summary>
            <param name="value">Value.</param>
            <param name="buffer">Buffer at least 8 bytes.</param>
            <param name="offset">The starting position within <paramref name="buffer" />.</param>
            <param name="asLittleEndian">Convert to little endian.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToUInt64(System.Byte[],System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts array of bytes to <see cref="T:System.UInt64" />.
            </summary>
            <param name="bytes">An array of bytes.</param>
            <param name="offset">The starting position within <paramref name="bytes" />.</param>
            <param name="asLittleEndian">Convert from little endian.</param>
            <returns><see cref="T:System.UInt64" /> value.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToBytes(HpTimeStamps.BigMath.Int128,System.Byte[],System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts an <see cref="T:HpTimeStamps.BigMath.Int128" /> value to an array of bytes.
            </summary>
            <param name="value">Value.</param>
            <param name="buffer">An array of bytes.</param>
            <param name="offset">The starting position within <paramref name="buffer" />.</param>
            <param name="asLittleEndian">Convert from little endian.</param>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToBytes(HpTimeStamps.BigMath.Int128,System.Nullable{System.Boolean},System.Boolean)">
            <summary>
                Converts an <see cref="T:HpTimeStamps.BigMath.Int128" /> value to a byte array.
            </summary>
            <param name="value">Value.</param>
            <param name="asLittleEndian">Convert from little endian.</param>
            <param name="trimZeros">Trim zero bytes from left or right, depending on endian.</param>
            <returns>Array of bytes.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.ExtendedBitConverter.ToInt128(System.Byte[],System.Int32,System.Nullable{System.Boolean})">
            <summary>
                Converts array of bytes to <see cref="T:HpTimeStamps.BigMath.Int128" />.
            </summary>
            <param name="bytes">An array of bytes.</param>
            <param name="offset">The starting position within <paramref name="bytes" />.</param>
            <param name="asLittleEndian">Convert from little endian.</param>
            <returns><see cref="T:HpTimeStamps.BigMath.Int128" /> value.</returns>
        </member>
        <member name="T:HpTimeStamps.BigMath.Utils.MathUtils">
            <summary>
                Math utils.
            </summary>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.MathUtils.Shift(System.Span{System.UInt64},System.Span{System.UInt64},System.Int32)">
            <summary>
                Bitwise shift array of <see cref="T:System.UInt64" />.
            </summary>
            <param name="values">Bits to shift. Lower bits have lower index in array.</param>
            <param name="shifted">shifted values go here ... must be same length as values, must be 2</param>
            <param name="shift">Shift amount in bits. Negative for left shift, positive for right shift.</param>
            <returns>Shifted values.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.MathUtils.ShiftRightSigned(System.Span{System.UInt64},System.Span{System.UInt64},System.Int32)">
            <summary>
                Sign extending right shift
                
                Using an array of ulong's, but when called from Int128 and Int256, value is really a signed number, so we need to preserve the sign bits
            </summary>
            <param name="values">Bits to shift. Lower bits have lower index in array.</param>
            <param name="shifted">shifted values go here.... must have same length (2) for the limited use herein</param>
            <param name="shift">Shift amount in bits.</param>
            <returns>Shifted values.</returns>
        </member>
        <member name="M:HpTimeStamps.BigMath.Utils.MathUtils.ShiftLeft(System.Span{System.UInt64},System.Span{System.UInt64},System.Int32)">
            <summary>
                Bitwise left shift.
            </summary>
            <param name="values">Bits to shift. Lower bits have lower index in array.</param>
            <param name="shifted">results go in here.... should be </param>
            <param name="shift">Shift amount in bits.</param>
            <returns>Shifted values.</returns>
        </member>
        <member name="T:HpTimeStamps.DelegateException">
            <summary>
            Exception that is thrown to indicate a supplied
            delegate has not fulfilled its contract with the entity
            to which it has been supplied.
            </summary>
        </member>
        <member name="P:HpTimeStamps.DelegateException.OffendingDelegate">
            <summary>
            The offending delegate
            </summary>
        </member>
        <member name="P:HpTimeStamps.DelegateException.DelegateName">
            <summary>
            The name of the offending delegate
            </summary>
        </member>
        <member name="M:HpTimeStamps.DelegateException.#ctor(System.String,System.String,System.Delegate,System.Exception)">
            <summary>
            CTOR
            </summary>
            <param name="message">message</param>
            <param name="offendingDelegateName">name of the offending delegate</param>
            <param name="offendingDelegate">the offending delegate</param>
            <param name="inner">if another exception is the cause of this exception, it should go here.</param>
            One or more of <exception cref="T:System.ArgumentNullException"><paramref name="message"/>, <paramref name="offendingDelegateName"/>, and
            <paramref name="offendingDelegate"/> was null</exception>
        </member>
        <member name="T:HpTimeStamps.DelegateReturnedNullException">
            <summary>
            Exception that is thrown to indicate a supplied delegate violated its contract
            with the object or function to which it was supplied by returning a null reference.
            </summary>
        </member>
        <member name="M:HpTimeStamps.DelegateReturnedNullException.#ctor(System.String,System.Delegate)">
            <summary>
            CTOR
            </summary>
            <param name="offendingDelegateName">name of the offending delegate</param>
            <param name="offendingDelegate">the offending delegate</param>
            <exception cref="T:System.ArgumentNullException">At least one argument was null.</exception>
        </member>
        <member name="T:HpTimeStamps.DelegateThrewException">
            <summary>
            An exception that is thrown to indicate that a delegate
            violated its contract with the object to which it was supplied by
            throwing an exception.
            </summary>
        </member>
        <member name="M:HpTimeStamps.DelegateThrewException.#ctor(System.String,System.Delegate,System.Exception)">
            <summary>
            CTOR
            </summary>
            <param name="offendingDelegateName">The name of the offending delegate.</param>
            <param name="offendingDelegate">The offending delegate.</param>
            <param name="inner">The exception that was thrown in violation of the delegate's contract.</param>
            <exception cref="T:System.ArgumentNullException">One or more arguments was null.</exception>
        </member>
        <member name="T:HpTimeStamps.Duration">
            <summary>
            Based on <see cref="T:System.TimeSpan"/> except <see cref="F:HpTimeStamps.Duration.TicksPerSecond"/> is based on <see cref="F:System.Diagnostics.Stopwatch.Frequency"/>
            rather than TimeSpan's.
            </summary>
            <remarks>Because <see cref="F:System.Diagnostics.Stopwatch.Frequency"/> is different in different environments, this duration should not be considered
            portable or usable across process boundaries.  DO NOT SERIALIZE OR USE ACROSS PROCESS BOUNDARIES.  Use </remarks>
        </member>
        <member name="F:HpTimeStamps.Duration.EasyConversionsToAndFromTimeSpan">
            <summary>
            True if conversion factors between durations and timespans likely to be round
            and without loss
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.EasyConversionsToAndFromPortableDuration">
            <summary>
            True if conversion factors between durations and timespans likely to be round
            and without loss
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.MinimumSupportedStopwatchTicksPerSecond">
            <summary>
            The smallest stopwatch frequency supported by this library.
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.TicksPerMillisecond">
            <summary>
            Number of ticks in a millisecond
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.TicksPerMicrosecond">
            <summary>
            Number of ticks in a microsecond
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.TicksPerSecond">
            <summary>
            Number of ticks in a second.  Unlike <see cref="T:System.TimeSpan"/>, this will always
            be keyed to <see cref="F:System.Diagnostics.Stopwatch.Frequency"/>.
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.TicksPerMinute">
            <summary>
            Number of ticks per minute
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.TicksPerHour">
            <summary>
            Number of ticks per hour.
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.TicksPerDay">
            <summary>
            Number of ticks per day 
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.Zero">
            <summary>
            Zero
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.MaxValue">
            <summary>
            Maximum value of a duration
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.MinValue">
            <summary>
            Minimum value of a duration
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.MaxSeconds">
            <summary>
            Longest positive period representable in seconds
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.MinSeconds">
            <summary>
            Longest negative period representable in seconds
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.MaxMilliseconds">
            <summary>
            Longest positive period represented in milliseconds
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.MinMilliseconds">
            <summary>
            Longest negative period represented in millisecond
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.TicksPerTenthSecond">
            <summary>
            Number of ticks in a tenth of a second
            </summary>
        </member>
        <member name="F:HpTimeStamps.Duration.TickIntRightShiftGetSignBitAmount">
            <summary>
            Amount to shift a <see cref="T:HpTimeStamps.BigMath.Int128"/> right to get its sign bit.
            </summary>
        </member>
        <member name="M:HpTimeStamps.Duration.op_Explicit(System.TimeSpan)~HpTimeStamps.Duration">
            <summary>
            Convert a timespan into a duration
            </summary>
            <param name="convertMe">value to convert</param>
            <exception cref="T:System.OverflowException">Can't fit.</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.op_Explicit(HpTimeStamps.Duration@)~System.TimeSpan">
            <summary>
            Convert a duration into a timespan
            </summary>
            <param name="convertMe">value to convert</param>
            <exception cref="T:System.OverflowException">Can't fit.</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.FromTimespanTicks(System.Int64)">
            <summary>
            Convert timespan ticks into a duration
            </summary>
            <param name="timespanTicks">the timespan ticks</param>
            <returns>a duration</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.FromDays(System.Double)">
            <summary>
            Compute a duration from a value representing days
            </summary>
            <param name="value">Value representing days</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a Duration.</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.FromHours(System.Double)">
            <summary>
            Compute a duration from a value representing hours
            </summary>
            <param name="value">Value representing days</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a Duration.</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.FromMilliseconds(System.Int64)">
            <summary>
            Compute a duration from a value representing milliseconds
            </summary>
            <param name="value">Value representing milliseconds</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a Duration.</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.FromMicroseconds(System.Int64)">
            <summary>
            Get a Duration from microseconds
            </summary>
            <param name="value">Microseconds</param>
            <returns>A duration consisting of <paramref name="value"/> microseconds.</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.FromMinutes(System.Double)">
            <summary>
            Compute a duration from a value representing minutes
            </summary>
            <param name="value">Value representing minutes</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a Duration.</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.FromSeconds(System.Double)">
            <summary>
            Compute a duration from a value representing seconds
            </summary>
            <param name="value">Value representing seconds</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a Duration.</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.FromStopwatchTicks(HpTimeStamps.BigMath.Int128@)">
            <summary>
            Create a duration from ticks
            </summary>
            <param name="value">ticks</param>
            <returns>the value</returns>
        </member>
        <member name="P:HpTimeStamps.Duration.Ticks">
            <summary>
            Stopwatch ticks
            </summary>
        </member>
        <member name="P:HpTimeStamps.Duration.Days">
            <summary>
            Number of whole days represented, fractional time remaining discarded.
            </summary>
        </member>
        <member name="P:HpTimeStamps.Duration.Hours">
            <summary>
            Number of whole hours represented, fractional time remaining discarded
            </summary>
        </member>
        <member name="P:HpTimeStamps.Duration.Milliseconds">
            <summary>
            Number of whole milliseconds represented, fractional time remaining discarded
            </summary>
        </member>
        <member name="P:HpTimeStamps.Duration.Microseconds">
            <summary>
            Number of whole microseconds represented, fractional time remaining discarded
            </summary>
        </member>
        <member name="P:HpTimeStamps.Duration.Minutes">
            <summary>
            Number of whole minutes represented, fractional time remaining discarded
            </summary>
        </member>
        <member name="P:HpTimeStamps.Duration.Seconds">
            <summary>
            Number of whole seconds represented, fractional time remaining discarded
            </summary>
        </member>
        <member name="P:HpTimeStamps.Duration.TotalDays">
            <summary>
            The duration represented in days, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimeStamps.Duration.TotalHours">
            <summary>
            The duration represented in hours, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimeStamps.Duration.TotalMicroseconds">
            <summary>
            Duration represented in microseconds, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimeStamps.Duration.TotalMilliseconds">
            <summary>
            The duration represented in milliseconds, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimeStamps.Duration.TotalMinutes">
            <summary>
            The duration represented in minutes, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimeStamps.Duration.TotalSeconds">
            <summary>
            The duration represented in seconds, including fractional parts
            </summary>
        </member>
        <member name="M:HpTimeStamps.Duration.#ctor(HpTimeStamps.BigMath.Int128@)">
            <summary>
            CTOR
            </summary>
            <param name="ticks">stopwatch ticks</param>
        </member>
        <member name="M:HpTimeStamps.Duration.#ctor(System.Int64)">
            <summary>
            Create a duration from stopwatch ticks
            </summary>
            <param name="stopwatchTicks">the ticks</param>
        </member>
        <member name="M:HpTimeStamps.Duration.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            CTOR
            </summary>
            <param name="hours">Hours</param>
            <param name="minutes">Minutes</param>
            <param name="seconds">Seconds</param>
            <exception cref="T:System.ArgumentException">Period too long to fit.</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            CTOR
            </summary>
            <param name="days">days</param>
            <param name="hours">hours</param>
            <param name="minutes">minutes</param>
            <param name="seconds">seconds</param>
            <exception cref="T:System.ArgumentException">Period too long to fit</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            CTOR
            </summary>
            <param name="days">days</param>
            <param name="hours">hours</param>
            <param name="minutes">minutes</param>
            <param name="seconds">seconds</param>
            <param name="milliseconds">milliseconds</param>
            <exception cref="T:System.ArgumentException">Period too long to fit.</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.ToString">
            <summary>
            Get a string representation
            </summary>
            <returns>a string representation</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.op_Equality(HpTimeStamps.Duration@,HpTimeStamps.Duration@)">
            <summary>
            Test two durations for equality
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if equal false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.op_Inequality(HpTimeStamps.Duration@,HpTimeStamps.Duration@)">
            <summary>
            Test two durations for inequality
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if not equal false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.op_LessThan(HpTimeStamps.Duration@,HpTimeStamps.Duration@)">
            <summary>
            Test two durations for to see if <paramref name="t1"/> is less than <paramref name="t2"/>
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if <paramref name="t1"/> is less than <paramref name="t2"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.op_LessThanOrEqual(HpTimeStamps.Duration@,HpTimeStamps.Duration@)">
            <summary>
            Test two durations for to see if <paramref name="t1"/> is less than or equal to <paramref name="t2"/>
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if <paramref name="t1"/> is less than or equal to <paramref name="t2"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.op_GreaterThan(HpTimeStamps.Duration@,HpTimeStamps.Duration@)">
            <summary>
            Test two durations for to see if <paramref name="t1"/> is greater than <paramref name="t2"/>
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if <paramref name="t1"/> is greater than <paramref name="t2"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.op_GreaterThanOrEqual(HpTimeStamps.Duration@,HpTimeStamps.Duration@)">
            <summary>
            Test two durations for to see if <paramref name="t1"/> is greater than or equal to <paramref name="t2"/>
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if <paramref name="t1"/> is greater than or equal to <paramref name="t2"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:HpTimeStamps.Duration.Equals(HpTimeStamps.Duration)">
            <inheritdoc />
        </member>
        <member name="M:HpTimeStamps.Duration.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:HpTimeStamps.Duration.CompareTo(HpTimeStamps.Duration)">
            <summary>
            Compare this duration to another to establish the order between them
            </summary>
            <param name="otherValue">value to compare</param>
            <returns>
            A positive number if this value succeeds <paramref name="otherValue"/> in sort order.
            Zero if this value has the same position in the sort order as <paramref name="otherValue"/>.
            A negative number if this value precedes <paramref name="otherValue"/> in sort order.
            </returns>
        </member>
        <member name="M:HpTimeStamps.Duration.Compare(HpTimeStamps.Duration@,HpTimeStamps.Duration@)">
            <summary>
            Compare two durations
            </summary>
            <param name="lhs">left hand comparand</param>
            <param name="rhs">right hand comparand</param>
            <returns>
            A positive number if <paramref name="lhs"/> succeeds <paramref name="rhs"/> in sort order.
            Zero if <paramref name="lhs"/> has the same position in the sort order as <paramref name="rhs"/>.
            A negative number if <paramref name="lhs"/> precedes <paramref name="rhs"/> in sort order.
            </returns>
        </member>
        <member name="M:HpTimeStamps.Duration.Multiply(System.Double)">
            <summary>
            Multiply this value by a specified factor
            </summary>
            <param name="factor">the factor</param>
            <returns>the product</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.Divide(System.Double)">
            <summary>
            Divide this value by a specified divisor
            </summary>
            <param name="divisor">the divisor</param>
            <returns>the product</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.Divide(HpTimeStamps.Duration)">
            <summary>
            Divide this value by another duration
            </summary>
            <param name="ts">the divisor</param>
            <returns>the quotient</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.op_Subtraction(HpTimeStamps.Duration@,HpTimeStamps.Duration@)">
            <summary>
            Subtract two durations
            </summary>
            <param name="t1">minuend</param>
            <param name="t2">subtrahend</param>
            <returns>difference</returns>
            <exception cref="T:System.OverflowException">Operation overflow</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.op_UnaryPlus(HpTimeStamps.Duration@)">
            <summary>
            Apply unary + operator
            </summary>
            <param name="t">operand</param>
            <returns>a value equal to <paramref name="t"/>/</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.op_Addition(HpTimeStamps.Duration@,HpTimeStamps.Duration@)">
            <summary>
            Add two addends
            </summary>
            <param name="t1">first addend</param>
            <param name="t2">second addend</param>
            <returns>sum</returns>
            <exception cref="T:System.OverflowException">Operation resulted in overflow</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.op_Multiply(System.Double,HpTimeStamps.Duration@)">
            <summary>
            Multiply a duration by a factor
            </summary>
            <param name="factor">the factor</param>
            <param name="timeSpan">the duration</param>
            <returns>the product</returns>
            <exception cref="T:System.OverflowException">Operation resulted in overflow.</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.op_Division(HpTimeStamps.Duration@,HpTimeStamps.Duration@)">
            <summary>
            Divide two durations
            </summary>
            <param name="t1">dividend</param>
            <param name="t2">divisor</param>
            <returns>quotient</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.op_Multiply(HpTimeStamps.Duration@,System.Double)">
            <summary>
            Multiply a duration 
            </summary>
            <param name="timeSpan">Duration factor</param>
            <param name="factor">factor</param>
            <returns>product</returns>
            <exception cref="T:System.ArgumentException"><paramref name="factor"/> was nan</exception>
            <exception cref="T:System.OverflowException">operation resulted in overflow</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.AbsoluteValue">
            <summary>
            Get the absolute value of this Duration
            </summary>
            <returns>the absolute value</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.Negate">
            <summary>
            Return the additive inverse of this value
            </summary>
            <returns>The additive inverse</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.Add(HpTimeStamps.Duration@)">
            <summary>
            Add another value to this one
            </summary>
            <param name="ts">value to add to this one</param>
            <returns>sum</returns>
            <exception cref="T:System.OverflowException">addition caused overflow</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.Subtract(HpTimeStamps.Duration@)">
            <summary>
            Subtract another value from this one
            </summary>
            <param name="ts">the subtrahend</param>
            <returns>the difference</returns>
            <exception cref="T:System.OverflowException">Result caused overflow.</exception>
        </member>
        <member name="M:HpTimeStamps.Duration.op_UnaryNegation(HpTimeStamps.Duration@)">
            <summary>
            Negate the duration
            </summary>
            <param name="t">The duration to negate</param>
            <returns>the additive inverse</returns>
        </member>
        <member name="M:HpTimeStamps.Duration.op_Division(HpTimeStamps.Duration@,System.Double)">
            <summary>
            Divide a duration by a divisor
            </summary>
            <param name="timeSpan">the dividend</param>
            <param name="divisor">divisor</param>
            <returns>quotient</returns>
            <exception cref="T:System.ArgumentException"><paramref name="divisor"/> was <see cref="F:System.Double.NaN"/>.</exception>
        </member>
        <member name="F:HpTimeStamps.Duration._ticks">
            <summary>
            Internal to allow fast direct access by other in this library.
            </summary>
        </member>
        <member name="T:HpTimeStamps.UnsupportedStopwatchException">
            <summary>
            Exceptions related to stopwatches this library does not support are derived herefrom.
            </summary>
        </member>
        <member name="M:HpTimeStamps.UnsupportedStopwatchException.#ctor(System.String,System.Exception)">
            <summary>
            CTOR
            </summary>
            <param name="message">A non-null message for the user.</param>
            <param name="inner">An inner exception, if applicable or null otherwise.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="message"/> was null.</exception>
        </member>
        <member name="T:HpTimeStamps.IMonotonicStampContext">
            <summary>
            The monotonic time stamp context should be implemented
            as a readonly struct
            </summary>
        </member>
        <member name="P:HpTimeStamps.IMonotonicStampContext.EasyConversionAllWays">
            <summary>
            True if both <see cref="P:HpTimeStamps.IMonotonicStampContext.EasyConversionToAndFromTimespanTicks"/> AND <see cref="P:HpTimeStamps.IMonotonicStampContext.EasyConversionToAndFromNanoseconds"/> are true.
            </summary>
        </member>
        <member name="P:HpTimeStamps.IMonotonicStampContext.EasyConversionToAndFromTimespanTicks">
            <summary>
            True if the conversion factor between timespan ticks and Monotonic stamp ticks is a power of 10
            </summary>
        </member>
        <member name="P:HpTimeStamps.IMonotonicStampContext.EasyConversionToAndFromNanoseconds">
            <summary>
            True if the conversion factor between monotonic stamp ticks and nanoseconds is a power of 10
            </summary>
        </member>
        <member name="P:HpTimeStamps.IMonotonicStampContext.IsInvalid">
            <summary>
            True if the struct implementing this interface
            was not properly initialized.  Usually
            testing <see cref="P:HpTimeStamps.IMonotonicStampContext.ContextId"/> against
            the <see langword = "default"/> value of <see cref="T:System.Guid"/>
            is sufficient
            </summary>
        </member>
        <member name="P:HpTimeStamps.IMonotonicStampContext.ContextId">
            <summary>
            Unique id
            </summary>
        </member>
        <member name="P:HpTimeStamps.IMonotonicStampContext.AllTimestampsUtc">
            <summary>
            True if <see cref="P:HpTimeStamps.IMonotonicStampContext.UtcDateTimeBeginReference"/> equals
            <see cref="P:HpTimeStamps.IMonotonicStampContext.LocalTimeBeginReference"/>, false otherwise
            </summary>
        </member>
        <member name="P:HpTimeStamps.IMonotonicStampContext.UtcDateTimeBeginReference">
            <summary>
            The UTC neutral date time represented by
            <see cref="P:HpTimeStamps.IMonotonicStampContext.ReferenceTicks"/>.
            </summary>
        </member>
        <member name="P:HpTimeStamps.IMonotonicStampContext.LocalTimeBeginReference">
            <summary>
            The local time version of <see cref="P:HpTimeStamps.IMonotonicStampContext.UtcDateTimeBeginReference"/>.
            If <see cref="P:HpTimeStamps.IMonotonicStampContext.AllTimestampsUtc"/>, this value is equal to <see cref="P:HpTimeStamps.IMonotonicStampContext.UtcDateTimeBeginReference"/>.
            </summary>
        </member>
        <member name="P:HpTimeStamps.IMonotonicStampContext.ReferenceTicks">
            <summary>
            The number of clock ticks that equals <see cref="P:HpTimeStamps.IMonotonicStampContext.UtcDateTimeBeginReference"/>
            </summary>
        </member>
        <member name="P:HpTimeStamps.IMonotonicStampContext.TicksPerSecond">
            <summary>
            The number of clock ticks in one second
            </summary>
        </member>
        <member name="P:HpTimeStamps.IMonotonicStampContext.UtcLocalTimeOffset">
            <summary>
            Difference between <see cref="P:HpTimeStamps.IMonotonicStampContext.UtcDateTimeBeginReference"/> and <see cref="P:HpTimeStamps.IMonotonicStampContext.LocalTimeBeginReference"/>.
            </summary>
        </member>
        <member name="P:HpTimeStamps.IMonotonicStampContext.NanosecondsFrequency">
            <summary>
            Number of nanoseconds per seconds
            </summary>
        </member>
        <member name="P:HpTimeStamps.IMonotonicStampContext.UtcLocalTimeOffsetAsDuration">
            <summary>
            Retrieve <see cref="P:HpTimeStamps.IMonotonicStampContext.UtcLocalTimeOffset"/> as a duration.
            </summary>
        </member>
        <member name="T:HpTimeStamps.InvalidPortableStampStringException">
            <summary>
            Exception is thrown when there is an error parsing a serialized portable monotonic timestamp
            </summary>
        </member>
        <member name="P:HpTimeStamps.InvalidPortableStampStringException.FaultySerializedText">
            <summary>
            The text that could not be deserialized into a portable monotonic timestamp.
            </summary>
        </member>
        <member name="T:HpTimeStamps.ITimeStampUtil">
            <summary>
            Note that the times retrieved are not more accurate in ABSOLUTE terms.
            If <see cref="P:HpTimeStamps.ITimeStampUtil.IsHighPrecision"/> successive calls to get timestamp will
            be more accurate (with respect to each other, within the <see cref="P:HpTimeStamps.ITimeStampUtil.CalibrationWindow"/>).  
            </summary>
        </member>
        <member name="P:HpTimeStamps.ITimeStampUtil.StopWatchTicksPerSecond">
            <summary>
            Number of ticks per second by the stop watch's (and if <see cref="P:HpTimeStamps.ITimeStampUtil.IsHighPrecision"/>, the HPET's)
            reckoning
            </summary>
        </member>
        <member name="P:HpTimeStamps.ITimeStampUtil.DateTimeTicksPerSecond">
            <summary>
            Number of ticks per second by DateTime and TimeSpan's reckoning
            </summary>
        </member>
        <member name="P:HpTimeStamps.ITimeStampUtil.IsHighPrecision">
            <summary>
            Check whether high precision timestamps are possible, if not,
            might as well use DateTime.Now (unless you want hp wherever possible)
            </summary>
        </member>
        <member name="P:HpTimeStamps.ITimeStampUtil.CurrentLocalTimeStamp">
            <summary>
            Like DateTime.Now but based off of a reading from the high precision event timer
            and then converted into terms of the local time system
            </summary>
        </member>
        <member name="P:HpTimeStamps.ITimeStampUtil.CurrentUtcTimeStamp">
            <summary>
            Like DateTime.UtcNow, but based off of a reading from the high precision event timer
            then converted into terms of utc time system
            </summary>
        </member>
        <member name="P:HpTimeStamps.ITimeStampUtil.CalibrationWindow">
            <summary>
            The amount of time calibration lasts for.
            </summary>
        </member>
        <member name="P:HpTimeStamps.ITimeStampUtil.TimeSinceLastCalibration">
            <summary>
            Amount of time since last calibration.
            </summary>
        </member>
        <member name="P:HpTimeStamps.ITimeStampUtil.IsCalibrated">
            <summary>
            Whether the util is calibrated at present
            </summary>
        </member>
        <member name="P:HpTimeStamps.ITimeStampUtil.LocalOffsetFromUtc">
            <summary>
            The offset from utc.  To get utc time from local, SUBTRACT this value from local.
            To get local from utc, add this value to utc.
            </summary>
        </member>
        <member name="M:HpTimeStamps.ITimeStampUtil.Calibrate">
            <summary>
            Manually force a calibration.  If not calibrated, upon call to
            <see cref="P:HpTimeStamps.ITimeStampUtil.CurrentLocalTimeStamp"/> or <see cref="P:HpTimeStamps.ITimeStampUtil.CurrentUtcTimeStamp"/> calibration will
            be performed before TimeStamp retrieval causing a delay.  If you want to avoid that,
            calling this will do the trick.
            </summary>
        </member>
        <member name="T:HpTimeStamps.LocklessLazyWriteOnceValue`1">
            <summary>
            
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:HpTimeStamps.LocklessLazyWriteOnceValue`1.IsSet">
            <summary>
            
            </summary>
        </member>
        <member name="M:HpTimeStamps.LocklessLazyWriteOnceValue`1.#ctor(System.Func{`0})">
            <summary>
            
            </summary>
            <param name="ctor"></param>
        </member>
        <member name="T:HpTimeStamps.MonotonicClockNotAvailableException">
            <summary>
            If the runtime / hardware does not have a monotonic clock available,  this exception is thrown.
            </summary>
        </member>
        <member name="M:HpTimeStamps.MonotonicClockNotAvailableException.#ctor">
            <summary>
            CTOR
            </summary>
        </member>
        <member name="T:HpTimeStamps.MonotonicStampContext">
            <summary>
            The implementation of <see cref="T:HpTimeStamps.IMonotonicStampContext"/> this library provides.
            </summary>
        </member>
        <member name="M:HpTimeStamps.MonotonicStampContext.CreateStampContext">
            <summary>
            Create a stamp context to serve as reference point for monotonic timestamps
            </summary>
            <returns>context value</returns>
        </member>
        <member name="F:HpTimeStamps.MonotonicStampContext.NanosecondsPerSecond">
            <summary>
            # nano seconds in a second
            </summary>
        </member>
        <member name="P:HpTimeStamps.MonotonicStampContext.NanosecondsFrequency">
            <summary>
            number of nanoseconds in a second
            </summary>
        </member>
        <member name="P:HpTimeStamps.MonotonicStampContext.EasyConversionAllWays">
            <inheritdoc />
        </member>
        <member name="P:HpTimeStamps.MonotonicStampContext.EasyConversionToAndFromTimespanTicks">
            <inheritdoc />
        </member>
        <member name="P:HpTimeStamps.MonotonicStampContext.EasyConversionToAndFromNanoseconds">
            <inheritdoc />
        </member>
        <member name="P:HpTimeStamps.MonotonicStampContext.IsInvalid">
            <inheritdoc />
        </member>
        <member name="P:HpTimeStamps.MonotonicStampContext.ContextId">
            <inheritdoc />
        </member>
        <member name="P:HpTimeStamps.MonotonicStampContext.UtcDateTimeBeginReference">
            <inheritdoc />
        </member>
        <member name="P:HpTimeStamps.MonotonicStampContext.LocalTimeBeginReference">
            <inheritdoc />
        </member>
        <member name="P:HpTimeStamps.MonotonicStampContext.ReferenceTicks">
            <inheritdoc />
        </member>
        <member name="P:HpTimeStamps.MonotonicStampContext.TicksPerSecond">
            <inheritdoc />
        </member>
        <member name="P:HpTimeStamps.MonotonicStampContext.UtcLocalTimeOffset">
            <inheritdoc />
        </member>
        <member name="P:HpTimeStamps.MonotonicStampContext.UtcLocalTimeOffsetAsDuration">
            <summary>
            The utc local offset expressed as a duration
            </summary>
        </member>
        <member name="P:HpTimeStamps.MonotonicStampContext.AllTimestampsUtc">
            <inheritdoc />
        </member>
        <member name="M:HpTimeStamps.MonotonicStampContext.ToString">
            <inheritdoc />
        </member>
        <member name="M:HpTimeStamps.MonotonicStampContext.GetHashCode">
            <summary>
            Get a value-based hash code for this object
            </summary>
            <returns>a hash code</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicStampContext.Equals(System.Object)">
            <summary>
            Test another object to see whether it has the same value as this one.
            </summary>
            <param name="obj">The other object</param>
            <returns>True if the other object is of the same type as this one and has
            the same value as this one.  False otherwise.</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicStampContext.Equals(HpTimeStamps.MonotonicStampContext)">
            <summary>
            Test to see whether another value of this type has the same value as this one
            </summary>
            <param name="other">the other value</param>
            <returns>true if same value, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicStampContext.op_Equality(HpTimeStamps.MonotonicStampContext@,HpTimeStamps.MonotonicStampContext@)">
            <summary>
            Tests two stamp contexts for value equality
            </summary>
            <param name="lhs">left hand comparand</param>
            <param name="rhs">right hand comparand</param>
            <returns>true if they have the same value, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicStampContext.op_Inequality(HpTimeStamps.MonotonicStampContext@,HpTimeStamps.MonotonicStampContext@)">
            <summary>
            Tests two stamp contexts for value inequality
            </summary>
            <param name="lhs">left hand comparand</param>
            <param name="rhs">right hand comparand</param>
            <returns>true if they have the distinct values, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicStampContext.op_GreaterThan(HpTimeStamps.MonotonicStampContext@,HpTimeStamps.MonotonicStampContext@)">
            <summary>
            Test to see whether the left hand comparand is greater than (succeeds in sort order) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is greater than the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicStampContext.op_LessThan(HpTimeStamps.MonotonicStampContext@,HpTimeStamps.MonotonicStampContext@)">
            <summary>
            Test to see whether the left hand comparand is less than (precedes in sort order) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is less than the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicStampContext.op_GreaterThanOrEqual(HpTimeStamps.MonotonicStampContext@,HpTimeStamps.MonotonicStampContext@)">
            <summary>
            Test to see whether the left hand comparand is greater than (i.e. succeeds in sort-order) or equal to (i.e. is identical
            with and therefore holds sample place in sort order as) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is greater than or equal to the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicStampContext.op_LessThanOrEqual(HpTimeStamps.MonotonicStampContext@,HpTimeStamps.MonotonicStampContext@)">
            <summary>
            Test to see whether the left hand comparand is less than than (i.e. precedes in sort-order) or equal to (i.e. is identical
            with and therefore holds sample place in sort order as) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is less than or equal to the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicStampContext.CompareTo(HpTimeStamps.MonotonicStampContext)">
            <summary>
            Compare this context with another to establish the ordering between them
            </summary>
            <param name="other">the other</param>
            <returns>A negative number if the this value precedes the other value in the sort order.
            Zero if the this value is identical to the other value (and thus occupies same space in sort order).
            A positive number if this value succeeds the other value in sort order.</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicStampContext.Compare(HpTimeStamps.MonotonicStampContext@,HpTimeStamps.MonotonicStampContext@)">
            <summary>
            Compare two monotonic stamp contexts to establish their
            positions relative to each other in the sort order.
            </summary>
            <param name="lhs">left-hand comparand</param>
            <param name="rhs">Right-hand comparand</param>
            <returns>A negative number if the left-hand comparand precedes the right-hand comparand in the sort order.
            Zero if the left-hand comparand is identical to the right hand comparand (and thus occupies same space in sort order).
            A positive number if the left-hand comparand succeeds the right-hand comparand in sort order.</returns>
        </member>
        <member name="T:HpTimeStamps.MonotonicTimeStamp`1">
             <summary>
             A monotonic time stamp is a time stamp retrieved from a monotonic clock.
             Monotonic clocks have the property that for any two tick queries at T0 and T1
             OCCURRING IN PROCESS the ticks returned from query at T1 will always be greater
             than or equal to the ticks retrieved at query T0 (where T1 happens after T0).
            
             Using DateTime.Now as a timestamp source is problematic because it is based on a system /
             wall clock.  System / wall clocks can change forwards or backwards and thus can be problematic
             when used with the expectation DateTime t2 - DateTime t1 will give the time elapsed between t2 and t1
             (when DateTime t1 was recorded at T0 and DateTime t2 recorded at T1 where T1 was later in time than T0).
             In fact, the difference could even be negative -- saying that the later time was earlier:
                 Daylights savings adjustments
                 User adjustments to system clock
                 System clock synchronization with a reference clock
                 leap seconds, etc
            
             These timestamps:
                 1- are obtained from a source with a finer resolution that most DateTimes
                 2- are obtained from a source unaffected by adjustments to the system clock,
                    DST, leap seconds, etc.
             Advantages:
                 1- individually represented simply as ticks from a monotonic clock 
                 2- a reference date time is correlated with a reference number of ticks from the monotonic clock 
                 3- can be considered a reference date time and an offset period.
                 4- when subtracting one from another WITHIN PROCESS, will yield a duration as accurate as the monotonic
                    clock supplying ticks
                 5- most useful when used to compare elapsed time between events 
             Disadvantages:
                 1- NEVER SERIALIZE OR SHARE OUTSIDE OF PROCESS
                 2- when interpreted as a date time, in the rare circumstances where the system clock changes, will be misleading
                 3- NEVER SERIALIZE OR SHARE OUTSIDE OF PROCESS -- useful for RUNNING program only.  You could convert to a date time
                    and serialize but may lose accuracy if the system clock and the monotonic clock are no longer in lockstep.
             </summary>
             <typeparam name="TStampContext">The common context used by all stamps parameterized with this type</typeparam>
             <remarks>DO NOT USE ACROSS PROCESSES!  DO NOT SERIALIZE!  NOT FOR ARCHIVE!</remarks>
        </member>
        <member name="P:HpTimeStamps.MonotonicTimeStamp`1.MaximumImportableDateTime">
            <summary>
            The maximum <see cref="T:System.DateTime"/> capable of being expressed in terms of the current monotonic context (i.e. converted into 
            a monotonic stamp).  Importing date times into monotonic stamps is not recommended.  Instead,
            if the monotonic stamp is going to be meaningful for beyond a brief period in the currently running process,
            it should be converted into a <see cref="T:System.DateTime"/> or a <see cref="T:HpTimeStamps.PortableMonotonicStamp"/>.
            </summary>
            <remarks>
            This amount will vary depending on system configuration.  Do not make assumptions -- it can get pretty strange on
            some systems.
            </remarks>
        </member>
        <member name="P:HpTimeStamps.MonotonicTimeStamp`1.MinimumImportableDateTime">
            <summary>
            The minimum <see cref="T:System.DateTime"/> capable of being expressed in terms of the current monotonic context (i.e. converted into 
            a monotonic stamp).  Importing date times into monotonic stamps is not recommended.  Instead,
            if the monotonic stamp is going to be meaningful for beyond a brief period in the currently running process,
            it should be converted into a <see cref="T:System.DateTime"/> or a <see cref="T:HpTimeStamps.PortableMonotonicStamp"/>.
            </summary>
            <remarks>
            This amount will vary depending on system configuration.  Do not make assumptions -- it can get pretty strange on
            some systems.
            </remarks>
        </member>
        <member name="P:HpTimeStamps.MonotonicTimeStamp`1.ReferenceTimeStamp">
            <summary>
            The timestamp that represents the reference time exactly.  It's <see cref="P:HpTimeStamps.MonotonicTimeStamp`1.Value"/> property
            should have it's "OffsetFromReference" property set to exactly zero.
            </summary>
        </member>
        <member name="P:HpTimeStamps.MonotonicTimeStamp`1.MaxValue">
            <summary>
            The maximum value of the monotonic timestamp in the current process.
            </summary>
            <remarks>
            Unlike <see cref="T:System.DateTime"/> and <see cref="T:HpTimeStamps.PortableMonotonicStamp"/>, this value may change from system to system.
            Make no assumptions about it beyond the promise it will not change in the currently running process.
            </remarks>
        </member>
        <member name="P:HpTimeStamps.MonotonicTimeStamp`1.MinValue">
            <summary>
            The minimum value of the monotonic timestamp in the current process.
            </summary>
            <remarks>
            Unlike <see cref="T:System.DateTime"/> and <see cref="T:HpTimeStamps.PortableMonotonicStamp"/>, this value may change from system to system.
            Make no assumptions about it beyond the promise it will not change in the currently running process.
            </remarks>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.op_Explicit(HpTimeStamps.PortableMonotonicStamp@)~HpTimeStamps.MonotonicTimeStamp{`0}">
            <summary>
            Convert a portable timestamp to a local timestamp
            </summary>
            <param name="ts">the portable timestamp to convert</param>
            <returns>The portable timestamp expressed in terms of the local in-process <typeparamref name="TStampContext"/>.</returns>
            <exception cref="T:System.Exception">The portable stamp cannot be expressed in terms of the local monotonic <typeparamref name="TStampContext"/>.
            This is likely because it refers to a date time outside the range of <see cref="T:System.DateTime"/> or is too far from the <typeparamref name="TStampContext"/>
            reference time to store the offset in a <see cref="T:System.Int64"/>.
            </exception>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.CreateFromRefTicks(System.Int64)">
            <summary>
            Create a monotonic timestamp from a tick count retrieved from the reference clock.
            </summary>
            <param name="referenceTicks">the tick count</param>
            <returns>a monotonic timestamp</returns>
        </member>
        <member name="P:HpTimeStamps.MonotonicTimeStamp`1.Context">
            <summary>
            The stamp context shared by all timestamps parameterized by <typeparamref name="TStampContext"/>.
            </summary>
        </member>
        <member name="P:HpTimeStamps.MonotonicTimeStamp`1.Value">
            <summary>
            Retrieve the data in the most honest/least problematic (though perhaps a little inconvenient)
            format available:
                1- The UTC reference date time
                2- the amount of time that elapsed between the utc reference time
                   and the recording of the stamp
                3- the difference between the local reference time and utc reference time
            </summary>
        </member>
        <member name="P:HpTimeStamps.MonotonicTimeStamp`1.ElapsedSinceUtcReference">
            <summary>
            Amount of time elapsed since the Utc Reference Time between the timestamp being recorded and the utc reference time 
            </summary>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.#ctor(System.Int64)">
            <summary>
            Private CTOR
            </summary>
            <param name="stopwatchTicks"></param>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.ToLocalDateTime">
            <summary>
            Convert the timestamp to a local date time.  If the system clock and the reference
            monotonic clock are out of sync (drift or adjustments made to system clock or time -- user edit,
            syncing of system clock, daylight savings adjustments, leap seconds, etc), may not be accurate.
            </summary>
            <returns>a datetime</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.ToUtcDateTime">
            <summary>
            Convert the timestamp to a utc date time.  If the system clock and the reference
            monotonic clock are out of sync (drift or adjustments made to system clock or time -- user edit,
            syncing of system clock, leap seconds, etc), may not be accurate.
            </summary>
            <returns>a date-time</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.op_Equality(HpTimeStamps.MonotonicTimeStamp{`0},HpTimeStamps.MonotonicTimeStamp{`0})">
            <summary>
            Tests two stamps for value equality
            </summary>
            <param name="lhs">left hand comparand</param>
            <param name="rhs">right hand comparand</param>
            <returns>true if they have the same value, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.op_Inequality(HpTimeStamps.MonotonicTimeStamp{`0},HpTimeStamps.MonotonicTimeStamp{`0})">
            <summary>
            Tests two stamps for value inequality
            </summary>
            <param name="lhs">left hand comparand</param>
            <param name="rhs">right hand comparand</param>
            <returns>true if they have the distinct values, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.op_GreaterThan(HpTimeStamps.MonotonicTimeStamp{`0},HpTimeStamps.MonotonicTimeStamp{`0})">
            <summary>
            Test to see whether the left hand comparand is greater than (succeeds in sort order) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is greater than the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.op_LessThan(HpTimeStamps.MonotonicTimeStamp{`0},HpTimeStamps.MonotonicTimeStamp{`0})">
            <summary>
            Test to see whether the left hand comparand is less than (precedes in sort order) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is less than the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.op_GreaterThanOrEqual(HpTimeStamps.MonotonicTimeStamp{`0},HpTimeStamps.MonotonicTimeStamp{`0})">
            <summary>
            Test to see whether the left hand comparand is greater than (i.e. succeeds in sort-order) or equal to (i.e. is identical
            with and therefore holds sample place in sort order as) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is greater than or equal to the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.op_LessThanOrEqual(HpTimeStamps.MonotonicTimeStamp{`0},HpTimeStamps.MonotonicTimeStamp{`0})">
            <summary>
            Test to see whether the left hand comparand is less than than (i.e. precedes in sort-order) or equal to (i.e. is identical
            with and therefore holds sample place in sort order as) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is less than or equal to the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.GetHashCode">
            <summary>
            Get a value-based hash code for this object
            </summary>
            <returns>a hash code</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.Equals(System.Object)">
            <summary>
            Test another object to see whether it has the same value as this one.
            </summary>
            <param name="other">The other object</param>
            <returns>True if the other object is of the same type as this one and has
            the same value as this one.  False otherwise.</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.Equals(HpTimeStamps.MonotonicTimeStamp{`0})">
            <summary>
            Test to see whether another value of this type has the same value as this one
            </summary>
            <param name="other">the other value</param>
            <returns>true if same value, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.CompareTo(HpTimeStamps.MonotonicTimeStamp{`0})">
            <summary>
            Compare this stamp with another to establish the ordering between them
            </summary>
            <param name="other">the other</param>
            <returns>A negative number if the this value precedes the other value in the sort order.
            Zero if the this value is identical to the other value (and thus occupies same space in sort order).
            A positive number if this value succeeds the other value in sort order.</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.op_Addition(HpTimeStamps.MonotonicTimeStamp{`0},HpTimeStamps.Duration)">
            <summary>
            Add a stamp and duration together yielding a stamp
            </summary>
            <param name="lhs">left hand stamp operand</param>
            <param name="rhs">right hand duration operand</param>
            <returns>a stamp that is the result of adding a stamp and duration together</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.op_Addition(HpTimeStamps.Duration,HpTimeStamps.MonotonicTimeStamp{`0})">
            <summary>
            Add a stamp and duration together yielding a stamp
            </summary>
            <param name="lhs">left hand duration operand</param>
            <param name="rhs">right hand stamp operand</param>
            <returns>a stamp that is the result of adding a stamp and duration together</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.op_Subtraction(HpTimeStamps.MonotonicTimeStamp{`0},HpTimeStamps.MonotonicTimeStamp{`0})">
            <summary>
            Subtract the right hand stamp from the left hand comparand, yielding
            the time elapsed between the two.
            </summary>
            <param name="lhs">the left hand operand</param>
            <param name="rhs">the right and operand</param>
            <returns>the amount of time elapsed between the operands</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.op_Subtraction(HpTimeStamps.MonotonicTimeStamp{`0},HpTimeStamps.Duration)">
            <summary>
            Subtract a duration from a stamp yielding a stamp
            </summary>
            <param name="lhs">the stamp minuend</param>
            <param name="rhs">the duration subtrahend</param>
            <returns>A stamp difference</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.ToString">
            <summary>
            Get a string representation of this value
            </summary>
            <returns>a string representation.</returns>
            <remarks>Will be printed as a local DateTime represented in ISO format.  If
            there has been significant drift between monotonic clock and system clock
            or if the system clock has changed due to user adjustments, synchro with clock server,
            daylight savings time, leap seconds ... may be inaccurate or misleading.</remarks>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.ToPortableStamp">
            <summary>
            Convert this value to a portable timestamp suitable
            for serialization / using across process boundaries
            </summary>
            <returns>A portable timestamp.</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStamp`1.ImportPortableTimestamp(HpTimeStamps.PortableMonotonicStamp@)">
            <summary>
            Convert 
            </summary>
            <param name="stamp"></param>
            <returns></returns>
        </member>
        <member name="M:HpTimeStamps.TimeSpanExtensions.TotalWholeNanoseconds(System.TimeSpan)">
            <summary>
            Convert a timespan into whole nanoseconds (discarding any fractional part left over)
            </summary>
            <param name="t">The timespan</param>
            <returns>A 128-bit integer representing the number of whole nanoseconds (discarding leftover)
            represented by <paramref name="t"/>.</returns>
        </member>
        <member name="M:HpTimeStamps.TimeSpanExtensions.ConvertForeignNanosecondsToLocalDuration(HpTimeStamps.BigMath.Int128@)">
            <summary>
            Convert foreign nanoseconds to a local duration
            </summary>
            <param name="convertMe">the foreign nanoseconds to convert</param>
            <returns>the local duration.</returns>
        </member>
        <member name="T:HpTimeStamps.MonotonicTimeStampUtil`1">
            <summary>
            A utility designed to create monotonic timestamps
            </summary>
            <typeparam name="TStampContext">The type of context this utility uses to create timestamps.</typeparam>
        </member>
        <member name="P:HpTimeStamps.MonotonicTimeStampUtil`1.StampNow">
            <summary>
            Retrieve a monotonic timestamp recorded right now.
            </summary>
        </member>
        <member name="P:HpTimeStamps.MonotonicTimeStampUtil`1.Now">
            <summary>
            Get a monotonic timestamp as a local date time.
            </summary>
            <remarks>
            If the system clock and the reference
            monotonic clock are out of sync (drift or adjustments made to system clock or time -- user edit,
            syncing of system clock, daylight savings adjustments, leap seconds, etc), may not be accurate
            in an ABSOLUTE sense.
            Subtracting/Comparing with another datetime obtained using this property
            IN PROCESS should be accurate.
            </remarks>
        </member>
        <member name="P:HpTimeStamps.MonotonicTimeStampUtil`1.UtcNow">
            <summary>
            Get a monotonic timestamp as a utc date time.
            </summary>
            <remarks>
            If the system clock and the reference
            monotonic clock are out of sync (drift or adjustments made to system clock or time -- user edit,
            syncing of system clock, leap seconds, etc), may not be accurate
            in an ABSOLUTE sense.
            Subtracting/Comparing with another datetime obtained using this property IN PROCESS
            should be accurate.
            </remarks>
        </member>
        <member name="P:HpTimeStamps.MonotonicTimeStampUtil`1.StampContext">
            <summary>
            The stamp context available by readonly-reference.  Once set for a particular instantiation of <typeparamref name="TStampContext"/>
            is immutable.  This value can be set by:
                - Accessing this property for the first time (will be set to <see cref="F:HpTimeStamps.MonotonicTimeStampUtil`1.TheStampContext"/>) OR
                - Calling <see cref="M:HpTimeStamps.MonotonicTimeStampUtil`1.TrySupplyNonDefaultContext(`0@)"/> or <see cref="M:HpTimeStamps.MonotonicTimeStampUtil`1.SupplyNonDefaultContextOrThrow(`0@)"/> (assuming call is successful).
                  For these calls to BE successful, must be called before first time this property is accessed.
            </summary>
        </member>
        <member name="P:HpTimeStamps.MonotonicTimeStampUtil`1.IsContextSet">
            <summary>
            True if <see cref="P:HpTimeStamps.MonotonicTimeStampUtil`1.StampContext"/> has been initialized, false otherwise.
            Initialization is caused by access to the <see cref="P:HpTimeStamps.MonotonicTimeStampUtil`1.StampContext"/> property or
            successful calls to <see cref="M:HpTimeStamps.MonotonicTimeStampUtil`1.TrySupplyNonDefaultContext(`0@)"/> or <see cref="M:HpTimeStamps.MonotonicTimeStampUtil`1.SupplyNonDefaultContextOrThrow(`0@)"/>.
            </summary>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStampUtil`1.TrySupplyNonDefaultContext(`0@)">
            <summary>
            Attempt to set the stamp context to the provided value
            </summary>
            <param name="context">The context</param>
            <returns>True for success, false for failure</returns>
        </member>
        <member name="M:HpTimeStamps.MonotonicTimeStampUtil`1.SupplyNonDefaultContextOrThrow(`0@)">
            <summary>
            Supply a non-default context object or throw an exception
            </summary>
            <param name="context">the non-default context</param>
            <exception cref="T:System.ArgumentException">The supplied context is invalid.</exception>
            <exception cref="T:System.InvalidOperationException">The context has already been set.</exception>
        </member>
        <member name="T:HpTimeStamps.PortableDuration">
            <summary>
            Based on <see cref="T:System.TimeSpan"/> and <see cref="T:HpTimeStamps.Duration"/>except <see cref="F:HpTimeStamps.PortableDuration.TicksPerSecond"/> is always a Nanoseconds frequency ... i.e.
            1_000_000_000 rather than <see cref="T:System.TimeSpan"/>'s which is variable based on .NET implementation or <see cref="T:HpTimeStamps.Duration"/> which is tied to <see cref="F:System.Diagnostics.Stopwatch.Frequency"/>.
            </summary>
            <remarks>Since this type is always represented as nanoseconds regardless of environment it, unlike <see cref="T:HpTimeStamps.Duration"/> is suitable for use across process boundaries and/or
            for serialization.</remarks>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.EasyConversionToAndFromDuration">
            <summary>
            True if conversion to and from <see cref="T:HpTimeStamps.Duration"/> is easy and not
            likely to have significant rounding errors.
            </summary>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.TicksPerMillisecond">
            <summary>
            Number of ticks in a millisecond
            </summary>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.TicksPerSecond">
            <summary>
            Number of ticks in a second.  Unlike <see cref="T:System.TimeSpan"/>, this will always
            be keyed to <see cref="F:System.Diagnostics.Stopwatch.Frequency"/>.
            </summary>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.TicksPerMinute">
            <summary>
            Number of ticks per minute
            </summary>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.TicksPerHour">
            <summary>
            Number of ticks per hour.
            </summary>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.TicksPerDay">
            <summary>
            Number of ticks per day 
            </summary>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.Zero">
            <summary>
            Zero
            </summary>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.MaxValue">
            <summary>
            Maximum value of a duration
            </summary>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.MinValue">
            <summary>
            Minimum value of a duration
            </summary>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.MaxSeconds">
            <summary>
            Longest positive period representable in seconds
            </summary>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.MinSeconds">
            <summary>
            Longest negative period representable in seconds
            </summary>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.MaxMilliseconds">
            <summary>
            Longest positive period represented in milliseconds
            </summary>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.MinMilliseconds">
            <summary>
            Longest negative period represented in millisecond
            </summary>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.TicksPerTenthSecond">
            <summary>
            Number of ticks in a tenth of a second
            </summary>
        </member>
        <member name="F:HpTimeStamps.PortableDuration.PdIntRightShiftGetSignBitAmount">
            <summary>
            Amount to shift a <see cref="T:HpTimeStamps.BigMath.Int128"/> right to get its sign bit.
            </summary>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_Implicit(System.TimeSpan)~HpTimeStamps.PortableDuration">
            <summary>
            Convert a timespan into a duration
            </summary>
            <param name="convertMe">value to convert</param>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_Explicit(HpTimeStamps.Duration@)~HpTimeStamps.PortableDuration">
            <summary>
            Convert a duration to a portable duration
            </summary>
            <param name="d">The duration to convert to a portable duration</param>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_Explicit(HpTimeStamps.PortableDuration@)~HpTimeStamps.Duration">
            <summary>
            Convert a portable duration into a duration
            </summary>
            <param name="d">the portable duration to convert</param>
            <returns>the portable duration</returns>
            <exception cref="T:System.OverflowException">Cannot fit in Duration/</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_Explicit(HpTimeStamps.PortableDuration@)~System.TimeSpan">
            <summary>
            Convert a duration into a timespan
            </summary>
            <param name="convertMe">value to convert</param>
            <exception cref="T:System.OverflowException">Can't fit.</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.FromTimespanTicks(System.Int64)">
            <summary>
            Convert timespan ticks into a duration
            </summary>
            <param name="timespanTicks">the timespan ticks</param>
            <returns>a duration</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.FromDays(System.Double)">
            <summary>
            Compute a duration from a value representing days
            </summary>
            <param name="value">Value representing days</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a PortableDuration.</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.FromHours(System.Double)">
            <summary>
            Compute a duration from a value representing hours
            </summary>
            <param name="value">Value representing days</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a PortableDuration.</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.FromMilliseconds(System.Double)">
            <summary>
            Compute a duration from a value representing milliseconds
            </summary>
            <param name="value">Value representing milliseconds</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a PortableDuration.</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.FromMicroseconds(System.Double)">
            <summary>
            Compute a duration from a value representing microseconds
            </summary>
            <param name="value">Value representing milliseconds</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a PortableDuration.</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.FromMicroseconds(System.Int64)">
            <summary>
            Compute a duration from a value representing microseconds
            </summary>
            <param name="value">Value representing microseconds</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a PortableDuration.</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.FromNanoseconds(System.Int64)">
            <summary>
            Compute a duration from a value representing nanoseconds
            </summary>
            <param name="nanoseconds">Value representing nanoseconds</param>
            <returns>A duration</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.FromMinutes(System.Double)">
            <summary>
            Compute a duration from a value representing minutes
            </summary>
            <param name="value">Value representing minutes</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a PortableDuration.</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.FromSeconds(System.Double)">
            <summary>
            Compute a duration from a value representing seconds
            </summary>
            <param name="value">Value representing seconds</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a PortableDuration.</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.FromStopwatchTicks(HpTimeStamps.BigMath.Int128@)">
            <summary>
            Create a duration from ticks
            </summary>
            <param name="value">ticks</param>
            <returns>the value</returns>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.InternalTicks">
            <summary>
            portable duration ticks
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.Days">
            <summary>
            Number of whole days represented, fractional time remaining discarded.
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.Hours">
            <summary>
            Number of whole hours represented, fractional time remaining discarded
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.Milliseconds">
            <summary>
            Number of whole milliseconds represented, fractional time remaining discarded
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.Microseconds">
            <summary>
            Number of whole microseconds represented, fractional time remaining discarded
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.Nanoseconds">
            <summary>
            Number of whole nanoseconds represented, fractional time remaining discarded
            </summary>
            <exception cref="T:System.OverflowException">Nanoseconds will not fit in <see cref="T:System.Int64"/>.</exception>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.Minutes">
            <summary>
            Number of whole minutes represented, fractional time remaining discarded
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.Seconds">
            <summary>
            Number of whole seconds represented, fractional time remaining discarded
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.TotalDays">
            <summary>
            The duration represented in days, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.TotalHours">
            <summary>
            The duration represented in hours, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.TotalMicroseconds">
            <summary>
            PortableDuration represented in microseconds, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.Ticks">
            <summary>
            Get ticks whole ticks as timespan ticks (1/10th of microsecond)
            if value will fit in 64 bit signed integer. If not, TenthsOfMicroseconds
            will be null.  Also get nano-seconds remainder (0-99)
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.TotalNanoseconds">
            <summary>
            PortableDuration represented in nanoseconds, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.TotalMilliseconds">
            <summary>
            The duration represented in milliseconds, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.TotalMinutes">
            <summary>
            The duration represented in minutes, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableDuration.TotalSeconds">
            <summary>
            The duration represented in seconds, including fractional parts
            </summary>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.#ctor(HpTimeStamps.BigMath.Int128@)">
            <summary>
            CTOR
            </summary>
            <param name="nanoseconds"># of nanoseconds</param>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.#ctor(System.Int64)">
            <summary>
            Create a duration from stopwatch ticks
            </summary>
            <param name="nanoseconds">number of nanoseconds</param>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            CTOR
            </summary>
            <param name="hours">Hours</param>
            <param name="minutes">Minutes</param>
            <param name="seconds">Seconds</param>
            <exception cref="T:System.ArgumentException">Period too long to fit.</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            CTOR
            </summary>
            <param name="days">days</param>
            <param name="hours">hours</param>
            <param name="minutes">minutes</param>
            <param name="seconds">seconds</param>
            <exception cref="T:System.ArgumentException">Period too long to fit</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            CTOR
            </summary>
            <param name="days">days</param>
            <param name="hours">hours</param>
            <param name="minutes">minutes</param>
            <param name="seconds">seconds</param>
            <param name="milliseconds">milliseconds</param>
            <exception cref="T:System.ArgumentException">Period too long to fit.</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.ToString">
            <summary>
            Get a string representation (nanoseconds)
            </summary>
            <returns>a string representation</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_Equality(HpTimeStamps.PortableDuration@,HpTimeStamps.PortableDuration@)">
            <summary>
            Test two durations for equality
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if equal false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_Inequality(HpTimeStamps.PortableDuration@,HpTimeStamps.PortableDuration@)">
            <summary>
            Test two durations for inequality
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if not equal false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_LessThan(HpTimeStamps.PortableDuration@,HpTimeStamps.PortableDuration@)">
            <summary>
            Test two durations for to see if <paramref name="t1"/> is less than <paramref name="t2"/>
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if <paramref name="t1"/> is less than <paramref name="t2"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_LessThanOrEqual(HpTimeStamps.PortableDuration@,HpTimeStamps.PortableDuration@)">
            <summary>
            Test two durations for to see if <paramref name="t1"/> is less than or equal to <paramref name="t2"/>
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if <paramref name="t1"/> is less than or equal to <paramref name="t2"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_GreaterThan(HpTimeStamps.PortableDuration@,HpTimeStamps.PortableDuration@)">
            <summary>
            Test two durations for to see if <paramref name="t1"/> is greater than <paramref name="t2"/>
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if <paramref name="t1"/> is greater than <paramref name="t2"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_GreaterThanOrEqual(HpTimeStamps.PortableDuration@,HpTimeStamps.PortableDuration@)">
            <summary>
            Test two durations for to see if <paramref name="t1"/> is greater than or equal to <paramref name="t2"/>
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if <paramref name="t1"/> is greater than or equal to <paramref name="t2"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:HpTimeStamps.PortableDuration.Equals(HpTimeStamps.PortableDuration)">
            <inheritdoc />
        </member>
        <member name="M:HpTimeStamps.PortableDuration.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:HpTimeStamps.PortableDuration.CompareTo(HpTimeStamps.PortableDuration)">
            <summary>
            Compare this duration to another to establish the order between them
            </summary>
            <param name="otherValue">value to compare</param>
            <returns>
            A positive number if this value succeeds <paramref name="otherValue"/> in sort order.
            Zero if this value has the same position in the sort order as <paramref name="otherValue"/>.
            A negative number if this value precedes <paramref name="otherValue"/> in sort order.
            </returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.Compare(HpTimeStamps.PortableDuration@,HpTimeStamps.PortableDuration@)">
            <summary>
            Compare two durations
            </summary>
            <param name="lhs">left hand comparand</param>
            <param name="rhs">right hand comparand</param>
            <returns>
            A positive number if <paramref name="lhs"/> succeeds <paramref name="rhs"/> in sort order.
            Zero if <paramref name="lhs"/> has the same position in the sort order as <paramref name="rhs"/>.
            A negative number if <paramref name="lhs"/> precedes <paramref name="rhs"/> in sort order.
            </returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.Multiply(System.Double)">
            <summary>
            Multiply this value by a specified factor
            </summary>
            <param name="factor">the factor</param>
            <returns>the product</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.Divide(System.Double)">
            <summary>
            Divide this value by a specified divisor
            </summary>
            <param name="divisor">the divisor</param>
            <returns>the product</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.Divide(HpTimeStamps.PortableDuration)">
            <summary>
            Divide this value by another duration
            </summary>
            <param name="ts">the divisor</param>
            <returns>the quotient</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_Subtraction(HpTimeStamps.PortableDuration@,HpTimeStamps.PortableDuration@)">
            <summary>
            Subtract two durations
            </summary>
            <param name="t1">minuend</param>
            <param name="t2">subtrahend</param>
            <returns>difference</returns>
            <exception cref="T:System.OverflowException">Operation overflow</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_UnaryPlus(HpTimeStamps.PortableDuration@)">
            <summary>
            Apply unary + operator
            </summary>
            <param name="t">operand</param>
            <returns>a value equal to <paramref name="t"/>/</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_Addition(HpTimeStamps.PortableDuration@,HpTimeStamps.PortableDuration@)">
            <summary>
            Add two addends
            </summary>
            <param name="t1">first addend</param>
            <param name="t2">second addend</param>
            <returns>sum</returns>
            <exception cref="T:System.OverflowException">Operation resulted in overflow</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_Multiply(System.Double,HpTimeStamps.PortableDuration@)">
            <summary>
            Multiply a duration by a factor
            </summary>
            <param name="factor">the factor</param>
            <param name="timeSpan">the duration</param>
            <returns>the product</returns>
            <exception cref="T:System.OverflowException">Operation resulted in overflow.</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_Division(HpTimeStamps.PortableDuration@,HpTimeStamps.PortableDuration@)">
            <summary>
            Divide two durations
            </summary>
            <param name="t1">dividend</param>
            <param name="t2">divisor</param>
            <returns>quotient</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_Multiply(HpTimeStamps.PortableDuration@,System.Double)">
            <summary>
            Multiply a duration 
            </summary>
            <param name="timeSpan">PortableDuration factor</param>
            <param name="factor">factor</param>
            <returns>product</returns>
            <exception cref="T:System.ArgumentException"><paramref name="factor"/> was nan</exception>
            <exception cref="T:System.OverflowException">operation resulted in overflow</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.AbsoluteValue">
            <summary>
            Get the absolute value of this PortableDuration
            </summary>
            <returns>the absolute value</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.Negate">
            <summary>
            Return the additive inverse of this value
            </summary>
            <returns>The additive inverse</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.Add(HpTimeStamps.PortableDuration@)">
            <summary>
            Add another value to this one
            </summary>
            <param name="ts">value to add to this one</param>
            <returns>sum</returns>
            <exception cref="T:System.OverflowException">addition caused overflow</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.Subtract(HpTimeStamps.PortableDuration@)">
            <summary>
            Subtract another value from this one
            </summary>
            <param name="ts">the subtrahend</param>
            <returns>the difference</returns>
            <exception cref="T:System.OverflowException">Result caused overflow.</exception>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_UnaryNegation(HpTimeStamps.PortableDuration@)">
            <summary>
            Negate the duration
            </summary>
            <param name="t">The duration to negate</param>
            <returns>the additive inverse</returns>
        </member>
        <member name="M:HpTimeStamps.PortableDuration.op_Division(HpTimeStamps.PortableDuration@,System.Double)">
            <summary>
            Divide a duration by a divisor
            </summary>
            <param name="timeSpan">the dividend</param>
            <param name="divisor">divisor</param>
            <returns>quotient</returns>
            <exception cref="T:System.ArgumentException"><paramref name="divisor"/> was <see cref="F:System.Double.NaN"/>.</exception>
        </member>
        <member name="F:HpTimeStamps.PortableDuration._ticks">
            <summary>
            Internal to allow fast direct access by other in this library.
            </summary>
        </member>
        <member name="T:HpTimeStamps.PortableMonotonicStamp">
             <summary>
             A portable monotonic stamp suitable for use across process boundaries and
             for serialization.  Time is stored in UTC so any information about local time zone will
             be lost.
            
              Represented internally as a 128 bit signed integer that represents nanoseconds elapsed
              since <see cref="F:System.DateTime.MinValue"/>, which is January 1, 0001 AD (UTC).
             </summary>
             <remarks>  note on message suppression: although the struct is technically mutable, mutation 
            can only occur during serialization and deserialization.  Value changing mutation can only
            occur during deserialization.  This type is essentially immutable: EVERY publicly exposed non-static method is readonly.
            Every static method / operator accepting values of this type accepts them by readonly-reference.  Also,
            even if the struct WERE mutable, that would only be a problem if the value were to change
            WHILE IT IS STORED IN A SORTED OR HASH-BASED ORDERED COLLECTION.  Since no commonly used collections 
            return such types by mutable reference, you cannot change value while resides therein anyway.</remarks>
        </member>
        <member name="F:HpTimeStamps.PortableMonotonicStamp.NanosecondsFrequency">
            <summary>
            Number of nanoseconds in a second
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableMonotonicStamp.MinValue">
            <summary>
            Minimum value representable 
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableMonotonicStamp.MaxValue">
            <summary>
            Maximum value representable
            </summary>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_Explicit(HpTimeStamps.MonotonicTimeStamp{HpTimeStamps.MonotonicStampContext}@)~HpTimeStamps.PortableMonotonicStamp">
            <summary>
            Convert a monotonic stamp to a portable stamp
            </summary>
            <param name="monotonicStamp">the monotonic stamp to convert</param>
            <remarks>Will be roundtrippable (less timezone info ... will be made UTC)
            unless the factors for conversion between monotonic stamps and nanoseconds are
            not conducive to even division.  <see cref="P:HpTimeStamps.MonotonicStampContext.EasyConversionToAndFromNanoseconds"/>.</remarks>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_Implicit(System.DateTime)~HpTimeStamps.PortableMonotonicStamp">
            <summary>
            Convert a date time to a portable timestamp
            </summary>
            <param name="convertMe">value to convert</param>
            <returns>converted value</returns>
            <remarks>If the source is a <see cref="T:System.DateTime"/>, will be roundtrippable back (with timezone locality stripped) </remarks>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_Explicit(HpTimeStamps.PortableMonotonicStamp@)~System.DateTime">
            <summary>
            Convert a monotonic stamp into a date time
            </summary>
            <param name="monotonicStamp"></param>
        </member>
        <member name="P:HpTimeStamps.PortableMonotonicStamp.NanosecondsSinceUtcEpoch">
            <summary>
            Amount of time in nanoseconds since the .NET UTC Epoch.
            </summary>
            <remarks>Value of .NET UTC epoch is calculated by calling <see cref="M:System.DateTime.ToUniversalTime"/>
            on <see cref="F:System.DateTime.MinValue"/></remarks>
        </member>
        <member name="P:HpTimeStamps.PortableMonotonicStamp.Year">
            <summary>
            The year (A.D. 0001 - 9999)
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableMonotonicStamp.Month">
            <summary>
            The month (1-12)
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableMonotonicStamp.Day">
            <summary>
            The day (1-28, 1-29, 1-30, 1-31 depending on <see cref="P:HpTimeStamps.PortableMonotonicStamp.Month"/>)
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableMonotonicStamp.Hour">
            <summary>
            The hour (0-23)
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableMonotonicStamp.Minutes">
            <summary>
            Then minutes (0-59)
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableMonotonicStamp.Seconds">
            <summary>
            The seconds (0-59)
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableMonotonicStamp.FractionalSeconds">
            <summary>
            The fractional seconds (1 - 9,999,999)
            </summary>
        </member>
        <member name="P:HpTimeStamps.PortableMonotonicStamp.TimeSinceEpoch">
            <summary>
            Amount of time elapsed since epoch
            </summary>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.ToLocalDateTime">
            <summary>
            Convert this to a datetime in the local datetime timezone.
            </summary>
            <returns>A local datetime</returns>
            <exception cref="T:HpTimeStamps.PortableTimestampOverflowException">Cannot be converted to
            DateTime because of overflow.</exception>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.ToUtcDateTime">
            <summary>
            Convert this into a utc datetime
            </summary>
            <returns>a utc datetime</returns>
            <exception cref="T:HpTimeStamps.PortableTimestampOverflowException">Cannot be converted to
            DateTime because of overflow.</exception>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.ToString">
            <summary>
            Get a string representation of this value in ISO 8601 format
            in UTC.
            </summary>
            <returns>A string representation.</returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.ToLocalString">
            <summary>
            Get a string representation of this value in ISO 8601 format
            in UTC.
            </summary>
            <returns>A string representation.</returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_Equality(HpTimeStamps.PortableMonotonicStamp@,HpTimeStamps.PortableMonotonicStamp@)">
            <summary>
            Test two portable monotonic stamps for value equality
            </summary>
            <param name="lhs">left hand operand</param>
            <param name="rhs">right hand operand</param>
            <returns>true if they have the same value, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_Inequality(HpTimeStamps.PortableMonotonicStamp@,HpTimeStamps.PortableMonotonicStamp@)">
            <summary>
            Test two portable monotonic stamps for value inequality
            </summary>
            <param name="lhs">left hand operand</param>
            <param name="rhs">right hand operand</param>
            <returns>true if they have different values, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_GreaterThan(HpTimeStamps.PortableMonotonicStamp@,HpTimeStamps.PortableMonotonicStamp@)">
            <summary>
            Test two portable monotonic stamps to see if <paramref name="lhs"/> is greater than
            <paramref name="rhs"/>.
            </summary>
            <param name="lhs">left hand operand</param>
            <param name="rhs">right hand operand</param>
            <returns>true if <paramref name="lhs"/> is greater than
            <paramref name="rhs"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_LessThan(HpTimeStamps.PortableMonotonicStamp@,HpTimeStamps.PortableMonotonicStamp@)">
            <summary>
            Test two portable monotonic stamps to see if <paramref name="lhs"/> is less than
            <paramref name="rhs"/>.
            </summary>
            <param name="lhs">left hand operand</param>
            <param name="rhs">right hand operand</param>
            <returns>true if <paramref name="lhs"/> is less than
            <paramref name="rhs"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_GreaterThanOrEqual(HpTimeStamps.PortableMonotonicStamp@,HpTimeStamps.PortableMonotonicStamp@)">
            <summary>
            Test two portable monotonic stamps to see if <paramref name="lhs"/> is greater or equal to than
            <paramref name="rhs"/>.
            </summary>
            <param name="lhs">left hand operand</param>
            <param name="rhs">right hand operand</param>
            <returns>true if <paramref name="lhs"/> is greater than
            <paramref name="rhs"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_LessThanOrEqual(HpTimeStamps.PortableMonotonicStamp@,HpTimeStamps.PortableMonotonicStamp@)">
            <summary>
            Test two portable monotonic stamps to see if <paramref name="lhs"/> is less or equal to than
            <paramref name="rhs"/>.
            </summary>
            <param name="lhs">left hand operand</param>
            <param name="rhs">right hand operand</param>
            <returns>true if <paramref name="lhs"/> is less than or equal to
            <paramref name="rhs"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.GetHashCode">
            <summary>
            A value based hash code for this value
            </summary>
            <returns>a hash code</returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.Equals(System.Object)">
            <summary>
            Check to see if this value has the same value as another object
            </summary>
            <param name="obj">the other object</param>
            <returns>True if the other object is a <see cref="T:HpTimeStamps.PortableMonotonicStamp"/>
            that has the same value as this one.  False otherwise
            </returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.Equals(HpTimeStamps.PortableMonotonicStamp)">
            <summary>
            Test to see whether this value is the same as another value
            of the same type.
            </summary>
            <param name="other">the other value</param>
            <returns>True if the other value has the same value as this one, false otherwise.</returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.CompareTo(HpTimeStamps.PortableMonotonicStamp)">
            <summary>
            Compare this value to another value of the same type to establish the ordering relation between them.
            </summary>
            <param name="other">the other object</param>
            <returns>
            Zero if this value and <paramref name="other"/> have identical position within sort order.
            A positive number if this value succeeds <paramref name="other"/> in the sort order.
            A negative number if this value precedes <paramref name="other"/> in the sort order.
            </returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.Compare(HpTimeStamps.PortableMonotonicStamp@,HpTimeStamps.PortableMonotonicStamp@)">
            <summary>
            Compare two <see cref="T:HpTimeStamps.PortableMonotonicStamp"/> values to establish the ordering between them.
            </summary>
            <param name="lhs">Left hand operand</param>
            <param name="rhs">Right hand operand</param>
            <returns>
            Zero if <paramref name="lhs"/> and <paramref name="rhs"/> have identical position within sort order.
            A positive number if <paramref name="lhs"/> succeeds <paramref name="rhs"/> in the sort order.
            A negative number if <paramref name="lhs"/> precedes <paramref name="rhs"/> in the sort order.
            </returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_Addition(HpTimeStamps.PortableMonotonicStamp@,HpTimeStamps.PortableDuration@)">
            <summary>
            Adds a duration to a stamp, yielding a stamp
            </summary>
            <param name="ms">the stamp addend</param>
            <param name="d">the duraton addend</param>
            <returns>the sum</returns>
            <exception cref="T:HpTimeStamps.PortableTimestampOverflowException">Caused overflow</exception>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_Addition(HpTimeStamps.PortableDuration@,HpTimeStamps.PortableMonotonicStamp@)">
            <summary>
            Adds a duration to a stamp, yielding a stamp
            </summary>
            <param name="ms">the stamp addend</param>
            <param name="d">the duraton addend</param>
            <returns>the sum</returns>
            <exception cref="T:HpTimeStamps.PortableTimestampOverflowException">Caused overflow</exception>        
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_Addition(HpTimeStamps.PortableMonotonicStamp@,System.TimeSpan)">
            <summary>
            Adds a timespan to a stamp, yielding a stamp
            </summary>
            <param name="ms">the stamp addend</param>
            <param name="ts">the timespan addend</param>
            <returns>the sum</returns>
            <exception cref="T:HpTimeStamps.PortableTimestampOverflowException">Caused overflow</exception>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_Addition(System.TimeSpan,HpTimeStamps.PortableMonotonicStamp@)">
            <summary>
            Adds a duration to a stamp, yielding a stamp
            </summary>
            <param name="ms">the stamp addend</param>
            <param name="ts">the timespan addend</param>
            <returns>the sum</returns>
            <exception cref="T:HpTimeStamps.PortableTimestampOverflowException">Caused overflow</exception>        
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_Subtraction(HpTimeStamps.PortableMonotonicStamp@,HpTimeStamps.PortableDuration@)">
            <summary>
            Subtracts a duration from a stamp, yielding a stamp
            </summary>
            <param name="minuend">Minuend</param>
            <param name="subtrahend">the subtrahend</param>
            <returns>the sum</returns>
            <exception cref="T:HpTimeStamps.PortableTimestampOverflowException">Caused overflow</exception>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_Subtraction(HpTimeStamps.PortableMonotonicStamp@,System.TimeSpan)">
            <summary>
            Subtracts a timespan from a stamp, yielding a stamp
            </summary>
            <param name="minuend">Minuend</param>
            <param name="subtrahend">the subtrahend</param>
            <returns>the sum</returns>
            <exception cref="T:HpTimeStamps.PortableTimestampOverflowException">Caused overflow</exception>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_Subtraction(HpTimeStamps.PortableMonotonicStamp@,HpTimeStamps.PortableMonotonicStamp@)">
            <summary>
            Subtracts a stamp from another stamp yielding the duration between them.
            </summary>
            <param name="minuend">the minuend</param>
            <param name="subtrahend">the subtrahend</param>
            <returns>the duration between the stamps</returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_Subtraction(HpTimeStamps.PortableMonotonicStamp@,System.DateTime)">
            <summary>
            Subtracts a DateTime from a stamp yielding the duration between them.
            </summary>
            <param name="minuend">the minuend</param>
            <param name="subtrahend">the subtrahend</param>
            <returns>the duration between the stamps</returns>
        </member>
        <member name="M:HpTimeStamps.PortableMonotonicStamp.op_Subtraction(System.DateTime,HpTimeStamps.PortableMonotonicStamp@)">
            <summary>
            Subtract a portable stamp from a date time yielding the duration between them
            </summary>
            <param name="minuend">the minuend</param>
            <param name="subtrahend">the subtrahend</param>
            <returns>the difference</returns>
        </member>
        <member name="T:HpTimeStamps.PortableTimestampOverflowException">
            <summary>
            Indicates that a portable timestamp cannot be converted to a local
            monotonic stamp or a local datetime or timespan because of overflow.
            </summary>
        </member>
        <member name="M:HpTimeStamps.PortableTimestampOverflowException.#ctor">
            <summary>
            Create an exception
            </summary>
        </member>
        <member name="M:HpTimeStamps.PortableTimestampOverflowException.#ctor(System.Exception)">
            <summary>
            Create an exception
            </summary>
            <param name="inner">inner exception, if applicable</param>
        </member>
        <member name="M:HpTimeStamps.PortableTimestampOverflowException.#ctor(System.String)">
            <summary>
            Create an exception
            </summary>
            <param name="msg">extra info to go in exception message, if applicable.</param>
        </member>
        <member name="M:HpTimeStamps.PortableTimestampOverflowException.#ctor(System.String,System.Exception)">
            <summary>
            Create an exception
            </summary>
            <param name="msg">Extra info that should go in message, if applicable</param>
            <param name="inner">Inner exception if applicable</param>
        </member>
        <member name="T:HpTimeStamps.TimeStampSource">
            <summary>
            Calibration is PER THREAD.  Calls are therefore thread-safe, but calibration may need to be done
            on each thread using this resource.
            </summary>
            <seealso cref="T:HpTimeStamps.TimeStampUtil">for more information</seealso>
        </member>
        <member name="P:HpTimeStamps.TimeStampSource.IsHighPrecision">
            <summary>
            True if high precision timestamps are used, false otherwise.
            </summary>
        </member>
        <member name="P:HpTimeStamps.TimeStampSource.UtcNow">
            <summary>
            High precision (if available) Utc timestamp
            </summary>
        </member>
        <member name="P:HpTimeStamps.TimeStampSource.Now">
            <summary>
            High precision (if available) timestamp available here
            </summary>
        </member>
        <member name="P:HpTimeStamps.TimeStampSource.NeedsCalibration">
            <summary>
            True if calibration is needed on THIS thread, false otherwise
            </summary>
        </member>
        <member name="P:HpTimeStamps.TimeStampSource.TimeSinceCalibration">
            <summary>
            How long has it been since calibration (on THIS thread)
            </summary>
        </member>
        <member name="P:HpTimeStamps.TimeStampSource.LocalUtcOffset">
            <summary>
            The offset from utc.  To get utc time from local, SUBTRACT this value from local.
            To get local from utc, add this value to utc.
            </summary>
        </member>
        <member name="M:HpTimeStamps.TimeStampSource.Calibrate">
            <summary>
            Perform calibration now for THIS thread
            </summary>
        </member>
        <member name="T:HpTimeStamps.TimeStampUtil">
             <summary>
             This struct is used in <see cref="T:HpTimeStamps.TimeStampSource"/> to provide high precision timestamps on a per thread basis.
             These timestamps have exactly the same format as timestamps retrieved by <see cref="P:System.DateTime.Now"/>, which
             corresponds to <see cref="P:HpTimeStamps.TimeStampUtil.CurrentLocalTimeStamp"/> herein and to <see cref="P:HpTimeStamps.TimeStampSource.Now"/> and <see cref="P:System.DateTime.UtcNow"/>,
             which corresponds to <see cref="P:HpTimeStamps.TimeStampUtil.CurrentUtcTimeStamp"/> herein and to <see cref="P:HpTimeStamps.TimeStampSource.UtcNow"/>.
            
             Please note that this (where hardware makes it possible) provides high PRECISION timestamps, not necessarily high ACCURACY
             timestamps.  DateTime.Now or .UtcNow may actually provide timestamps that are more accurate in terms of lack
             of deviation from official times.  These timestamps, however, should be -- on a single thread at least -- more accurate with respect
             to successively retrieved timestamps within a rather short period of time because they, where possible, make use of the hardware's high precision
             event timer.
            
             Calibration occurs on a per-thread basis by retrieving establishing an offset between the ticks value of DateTime.Now and the
             high precision event timer.  It then converts subsequent readings from the high precision timer back into DateTime format.
            
             As the time since <see cref="P:HpTimeStamps.TimeStampUtil.TimeSinceLastCalibration"/> increases, the high precision timer becomes LESS ACCURATE vis-a-vis
             "absolute" real time, but remains accurate with respect to the elapsed time the last time stamp was retrieved, a short time ago.
             Every time <see cref="P:HpTimeStamps.TimeStampUtil.TimeSinceLastCalibration"/> elapses, the next time stamp retrieval will recalibrate, causing retrieval to
             take slightly longer.  You can call <see cref="M:HpTimeStamps.TimeStampUtil.Calibrate"/> manually to do this yourself immediately before retrieving timestamps.
            
             The use-case for these timestamps is when you need timestamps that are approximately accurate vis-a-vis the system clock but also
             occasionally use them to measure elapsed time between events that occur in fractions of a millisecond.  In the latter use, they should
             be far better suited than DateTime.Now.  They may be somewhat less accurate than DateTime.Now with respect to the absolute, official
             UTC time, but remain accurate enough for many such purposes.
            
             Note that this library may malfunction until recalibration if the system clock changes ... at least until recalibration occurs.
            
             This struct is a time stamp util.  It should be accessed via TimeStampSource.
             If you wish to make your own time stamp util struct, make sure it has all the same public
             methods, operators and properties that this struct has.  Then alter the alias at the top of
             <see cref="T:HpTimeStamps.TimeStampSource"/>file to use yours and then recompile.  I do not recommend using interface
             as that introduces unneeded delay.
            
             The time stamp state is all thread local.  This means that calibration is done on a per thread basis.
             
             </summary>
        </member>
        <member name="P:HpTimeStamps.TimeStampUtil.IsHighPrecision">
            <summary>
            True if a high precision event timer is available, false otherwise
            </summary>
        </member>
        <member name="P:HpTimeStamps.TimeStampUtil.IsCalibrated">
            <summary>
            True if the util has a current calibration.  <seealso cref="P:HpTimeStamps.TimeStampUtil.CalibrationWindow"/> for how long
            calibration lasts before becoming considered stale.
            </summary>
        </member>
        <member name="P:HpTimeStamps.TimeStampUtil.LocalOffsetFromUtc">
            <inheritdoc />
        </member>
        <member name="P:HpTimeStamps.TimeStampUtil.StopWatchTicksPerSecond">
            <summary>
            How many high precision ticks per second are there?
            </summary>
        </member>
        <member name="P:HpTimeStamps.TimeStampUtil.DateTimeTicksPerSecond">
            <summary>
            How many date time ticks per second are there?
            </summary>
        </member>
        <member name="P:HpTimeStamps.TimeStampUtil.TimeSinceLastCalibration">
            <summary>
            How much time has elapsed since last calibration (per thread)
            </summary>
        </member>
        <member name="P:HpTimeStamps.TimeStampUtil.CalibrationWindow">
            <summary>
            How much time may elapse before calibration becomes considered stale.
            </summary>
        </member>
        <member name="P:HpTimeStamps.TimeStampUtil.CurrentUtcTimeStamp">
            <summary>
            Not yet tested; probably will not work.
            todo fixit make it work
            </summary>
        </member>
        <member name="P:HpTimeStamps.TimeStampUtil.CurrentLocalTimeStamp">
            <summary>
            Analog for <seealso cref="P:System.DateTime.Now"/> uses higher precision
            </summary>
        </member>
        <member name="M:HpTimeStamps.TimeStampUtil.Calibrate">
            <summary>
            Perform calibration
            </summary>
        </member>
        <member name="M:HpTimeStamps.TimeStampUtil.op_Equality(HpTimeStamps.TimeStampUtil,HpTimeStamps.TimeStampUtil)">
            <summary>
            Always true ... all state is thread local and static
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:HpTimeStamps.TimeStampUtil.op_Inequality(HpTimeStamps.TimeStampUtil,HpTimeStamps.TimeStampUtil)">
            <summary>
            Always false, all state is thread local and static
            </summary>
            <returns>false</returns>
        </member>
        <member name="M:HpTimeStamps.TimeStampUtil.Equals(HpTimeStamps.TimeStampUtil)">
            <summary>
            Always true ... all state is thread local and static
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:HpTimeStamps.TimeStampUtil.GetHashCode">
            <summary>
            397 is always the hash code.  All instances are considered equal
            </summary>
            <returns>397</returns>
        </member>
        <member name="M:HpTimeStamps.TimeStampUtil.Equals(HpTimeStamps.ITimeStampUtil)">
            <summary>
            True if <paramref name="other"/> is a not null and is of type <see cref="T:HpTimeStamps.TimeStampUtil"/>,
            false otherwise.
            </summary>
            <param name="other">Another object implementing this interface</param>
            <returns>True if <paramref name="other"/> is a not null and is of type <see cref="T:HpTimeStamps.TimeStampUtil"/>,
            false otherwise.</returns>
        </member>
        <member name="M:HpTimeStamps.TimeStampUtil.Equals(System.Object)">
            <summary>
            True if <paramref name="other"/> is a not null and is of type <see cref="T:HpTimeStamps.TimeStampUtil"/>,
            false otherwise.
            </summary>
            <param name="other">Another object implementing this interface</param>
            <returns>True if <paramref name="other"/> is a not null and is of type <see cref="T:HpTimeStamps.TimeStampUtil"/>,
            false otherwise.</returns>
        </member>
        <member name="T:HpTimeStamps.UnsupportedDateTimeRangeException">
             <summary>
             This exception is thrown to indicate that on the current system,
             calling <see cref="M:System.DateTime.ToUniversalTime"/> on <see cref="F:System.DateTime.MinValue"/>
             yields a result outside of a range this library supports.
            
             Currently, to be supported, <see cref="T:System.DateTime"/>'s minimum value, converted to
             universal time, must be Year: 0001, Month: January.  Thus any value after January 0001
             will be out of range and unsupported.
             </summary>
        </member>
        <member name="T:HpTimeStamps.UnsupportedStopwatchResolutionException">
            <summary>
            An exception that is thrown to indicate that the system's stopwatch does not meet minimum resolution requirements
            for the stopwatch.
            </summary>
        </member>
        <member name="P:HpTimeStamps.UnsupportedStopwatchResolutionException.ActualStopwatchFrequency">
            <summary>
            The frequency of the current system's stopwatch
            </summary>
        </member>
        <member name="P:HpTimeStamps.UnsupportedStopwatchResolutionException.RequiredStopwatchMinimumFrequency">
            <summary>
            The minimum supported frequency for this system's stopwatch
            </summary>
        </member>
        <member name="M:HpTimeStamps.UnsupportedStopwatchResolutionException.#ctor(System.Int64,System.Int64)">
            <summary>
            CTOR
            </summary>
            <param name="actualFrequency">actual frequency of this system's stopwatch</param>
            <param name="minimumRequiredFrequency">the minimum frequency this library supports</param>
        </member>
        <member name="M:HpTimeStamps.UnsupportedStopwatchResolutionException.#ctor(System.Int64,System.Int64,System.String,System.Exception)">
            <summary>
            CTOR
            </summary>
            <param name="actualFrequency">actual frequency of this system's stopwatch</param>
            <param name="minimumRequiredFrequency">the minimum frequency this library supports</param>
            <param name="extraInfo">optionally, extra information</param>
            <param name="inner">optionally, an inner exception that caused this exception.</param>
        </member>
    </members>
</doc>

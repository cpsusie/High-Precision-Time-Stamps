<?xml version="1.0"?>
<doc>
    <assembly>
        <name>HighPrecisionTimeStamps</name>
    </assembly>
    <members>
        <member name="T:HpTimesStamps.DelegateException">
            <summary>
            Exception that is thrown to indicate a supplied
            delegate has not fulfilled its contract with the entity
            to which it has been supplied.
            </summary>
        </member>
        <member name="P:HpTimesStamps.DelegateException.OffendingDelegate">
            <summary>
            The offending delegate
            </summary>
        </member>
        <member name="P:HpTimesStamps.DelegateException.DelegateName">
            <summary>
            The name of the offending delegate
            </summary>
        </member>
        <member name="M:HpTimesStamps.DelegateException.#ctor(System.String,System.String,System.Delegate,System.Exception)">
            <summary>
            CTOR
            </summary>
            <param name="message">message</param>
            <param name="offendingDelegateName">name of the offending delegate</param>
            <param name="offendingDelegate">the offending delegate</param>
            <param name="inner">if another exception is the cause of this exception, it should go here.</param>
            One or more of <exception cref="T:System.ArgumentNullException"><paramref name="message"/>, <paramref name="offendingDelegateName"/>, and
            <paramref name="offendingDelegate"/> was null</exception>
        </member>
        <member name="T:HpTimesStamps.DelegateReturnedNullException">
            <summary>
            Exception that is thrown to indicate a supplied delegate violated its contract
            with the object or function to which it was supplied by returning a null reference.
            </summary>
        </member>
        <member name="M:HpTimesStamps.DelegateReturnedNullException.#ctor(System.String,System.Delegate)">
            <summary>
            CTOR
            </summary>
            <param name="offendingDelegateName">name of the offending delegate</param>
            <param name="offendingDelegate">the offending delegate</param>
            <exception cref="T:System.ArgumentNullException">At least one argument was null.</exception>
        </member>
        <member name="T:HpTimesStamps.DelegateThrewException">
            <summary>
            An exception that is thrown to indicate that a delegate
            violated its contract with the object to which it was supplied by
            throwing an exception.
            </summary>
        </member>
        <member name="M:HpTimesStamps.DelegateThrewException.#ctor(System.String,System.Delegate,System.Exception)">
            <summary>
            CTOR
            </summary>
            <param name="offendingDelegateName">The name of the offending delegate.</param>
            <param name="offendingDelegate">The offending delegate.</param>
            <param name="inner">The exception that was thrown in violation of the delegate's contract.</param>
            <exception cref="T:System.ArgumentNullException">One or more arguments was null.</exception>
        </member>
        <member name="T:HpTimesStamps.Duration">
            <summary>
            Based on <see cref="T:System.TimeSpan"/> except <see cref="F:HpTimesStamps.Duration.TicksPerSecond"/> is based on <see cref="F:System.Diagnostics.Stopwatch.Frequency"/>
            rather than TimeSpan's.
            </summary>
        </member>
        <member name="F:HpTimesStamps.Duration.TicksPerMillisecond">
            <summary>
            Number of ticks in a millisecond
            </summary>
        </member>
        <member name="F:HpTimesStamps.Duration.TicksPerSecond">
            <summary>
            Number of ticks in a second.  Unlike <see cref="T:System.TimeSpan"/>, this will always
            be keyed to <see cref="F:System.Diagnostics.Stopwatch.Frequency"/>.
            </summary>
        </member>
        <member name="F:HpTimesStamps.Duration.TicksPerMinute">
            <summary>
            Number of ticks per minute
            </summary>
        </member>
        <member name="F:HpTimesStamps.Duration.TicksPerHour">
            <summary>
            Number of ticks per hour.
            </summary>
        </member>
        <member name="F:HpTimesStamps.Duration.TicksPerDay">
            <summary>
            Number of ticks per day 
            </summary>
        </member>
        <member name="F:HpTimesStamps.Duration.Zero">
            <summary>
            Zero
            </summary>
        </member>
        <member name="F:HpTimesStamps.Duration.MaxValue">
            <summary>
            Maximum value of a duration
            </summary>
        </member>
        <member name="F:HpTimesStamps.Duration.MinValue">
            <summary>
            Minimum value of a duration
            </summary>
        </member>
        <member name="F:HpTimesStamps.Duration.MaxSeconds">
            <summary>
            Longest positive period representable in seconds
            </summary>
        </member>
        <member name="F:HpTimesStamps.Duration.MinSeconds">
            <summary>
            Longest negative period representable in seconds
            </summary>
        </member>
        <member name="F:HpTimesStamps.Duration.MaxMilliseconds">
            <summary>
            Longest positive period represented in milliseconds
            </summary>
        </member>
        <member name="F:HpTimesStamps.Duration.MinMilliseconds">
            <summary>
            Longest negative period represented in millisecond
            </summary>
        </member>
        <member name="F:HpTimesStamps.Duration.TicksPerTenthSecond">
            <summary>
            Number of ticks in a tenth of a second
            </summary>
        </member>
        <member name="F:HpTimesStamps.Duration.TickIntRightShiftGetSignBitAmount">
            <summary>
            Amount to shift a <see cref="T:System.Int64"/> right to get its sign bit.
            </summary>
        </member>
        <member name="M:HpTimesStamps.Duration.op_Implicit(System.TimeSpan)~HpTimesStamps.Duration">
            <summary>
            Convert a timespan into a duration
            </summary>
            <param name="convertMe">value to convert</param>
        </member>
        <member name="M:HpTimesStamps.Duration.op_Explicit(HpTimesStamps.Duration@)~System.TimeSpan">
            <summary>
            Convert a duration into a timespan
            </summary>
            <param name="convertMe">value to convert</param>
            <exception cref="T:System.OverflowException">Can't fit.</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.FromTimespanTicks(System.Int64)">
            <summary>
            Convert timespan ticks into a duration
            </summary>
            <param name="timespanTicks">the timespan ticks</param>
            <returns>a duration</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.FromDays(System.Double)">
            <summary>
            Compute a duration from a value representing days
            </summary>
            <param name="value">Value representing days</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a Duration.</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.FromHours(System.Double)">
            <summary>
            Compute a duration from a value representing hours
            </summary>
            <param name="value">Value representing days</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a Duration.</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.FromMilliseconds(System.Double)">
            <summary>
            Compute a duration from a value representing milliseconds
            </summary>
            <param name="value">Value representing milliseconds</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a Duration.</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.FromMinutes(System.Double)">
            <summary>
            Compute a duration from a value representing minutes
            </summary>
            <param name="value">Value representing minutes</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a Duration.</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.FromSeconds(System.Double)">
            <summary>
            Compute a duration from a value representing seconds
            </summary>
            <param name="value">Value representing seconds</param>
            <returns>A duration</returns>
            <exception cref="T:System.ArgumentException">Value not representable as a Duration.</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.FromTicks(System.Int64@)">
            <summary>
            Create a duration from ticks
            </summary>
            <param name="value">ticks</param>
            <returns>the value</returns>
        </member>
        <member name="P:HpTimesStamps.Duration.Ticks">
            <summary>
            Stopwatch ticks
            </summary>
        </member>
        <member name="P:HpTimesStamps.Duration.Days">
            <summary>
            Number of whole days represented, fractional time remaining discarded.
            </summary>
        </member>
        <member name="P:HpTimesStamps.Duration.Hours">
            <summary>
            Number of whole hours represented, fractional time remaining discarded
            </summary>
        </member>
        <member name="P:HpTimesStamps.Duration.Milliseconds">
            <summary>
            Number of whole milliseconds represented, fractional time remaining discarded
            </summary>
        </member>
        <member name="P:HpTimesStamps.Duration.Minutes">
            <summary>
            Number of whole minutes represented, fractional time remaining discarded
            </summary>
        </member>
        <member name="P:HpTimesStamps.Duration.Seconds">
            <summary>
            Number of whole seconds represented, fractional time remaining discarded
            </summary>
        </member>
        <member name="P:HpTimesStamps.Duration.TotalDays">
            <summary>
            The duration represented in days, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimesStamps.Duration.TotalHours">
            <summary>
            The duration represented in hours, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimesStamps.Duration.TotalMilliseconds">
            <summary>
            The duration represented in milliseconds, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimesStamps.Duration.TotalMinutes">
            <summary>
            The duration represented in minutes, including fractional parts
            </summary>
        </member>
        <member name="P:HpTimesStamps.Duration.TotalSeconds">
            <summary>
            The duration represented in seconds, including fractional parts
            </summary>
        </member>
        <member name="M:HpTimesStamps.Duration.#ctor(System.Int64@)">
            <summary>
            CTOR
            </summary>
            <param name="ticks">stopwatch ticks</param>
        </member>
        <member name="M:HpTimesStamps.Duration.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            CTOR
            </summary>
            <param name="hours">Hours</param>
            <param name="minutes">Minutes</param>
            <param name="seconds">Seconds</param>
            <exception cref="T:System.ArgumentException">Period too long to fit.</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            CTOR
            </summary>
            <param name="days">days</param>
            <param name="hours">hours</param>
            <param name="minutes">minutes</param>
            <param name="seconds">seconds</param>
            <exception cref="T:System.ArgumentException">Period too long to fit</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            CTOR
            </summary>
            <param name="days">days</param>
            <param name="hours">hours</param>
            <param name="minutes">minutes</param>
            <param name="seconds">seconds</param>
            <param name="milliseconds">milliseconds</param>
            <exception cref="T:System.ArgumentException">Period too long to fit.</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.ToString">
            <summary>
            Get a string representation
            </summary>
            <returns>a string representation</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.op_Equality(HpTimesStamps.Duration@,HpTimesStamps.Duration@)">
            <summary>
            Test two durations for equality
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if equal false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.op_Inequality(HpTimesStamps.Duration@,HpTimesStamps.Duration@)">
            <summary>
            Test two durations for inequality
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if not equal false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.op_LessThan(HpTimesStamps.Duration@,HpTimesStamps.Duration@)">
            <summary>
            Test two durations for to see if <paramref name="t1"/> is less than <paramref name="t2"/>
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if <paramref name="t1"/> is less than <paramref name="t2"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.op_LessThanOrEqual(HpTimesStamps.Duration@,HpTimesStamps.Duration@)">
            <summary>
            Test two durations for to see if <paramref name="t1"/> is less than or equal to <paramref name="t2"/>
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if <paramref name="t1"/> is less than or equal to <paramref name="t2"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.op_GreaterThan(HpTimesStamps.Duration@,HpTimesStamps.Duration@)">
            <summary>
            Test two durations for to see if <paramref name="t1"/> is greater than <paramref name="t2"/>
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if <paramref name="t1"/> is greater than <paramref name="t2"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.op_GreaterThanOrEqual(HpTimesStamps.Duration@,HpTimesStamps.Duration@)">
            <summary>
            Test two durations for to see if <paramref name="t1"/> is greater than or equal to <paramref name="t2"/>
            </summary>
            <param name="t1">left hand operand</param>
            <param name="t2">right hand operand</param>
            <returns>true if <paramref name="t1"/> is greater than or equal to <paramref name="t2"/>, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:HpTimesStamps.Duration.Equals(HpTimesStamps.Duration)">
            <inheritdoc />
        </member>
        <member name="M:HpTimesStamps.Duration.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:HpTimesStamps.Duration.CompareTo(HpTimesStamps.Duration)">
            <summary>
            Compare this duration to another to establish the order between them
            </summary>
            <param name="otherValue">value to compare</param>
            <returns>
            A positive number if this value succeeds <paramref name="otherValue"/> in sort order.
            Zero if this value has the same position in the sort order as <paramref name="otherValue"/>.
            A negative number if this value precedes <paramref name="otherValue"/> in sort order.
            </returns>
        </member>
        <member name="M:HpTimesStamps.Duration.Compare(HpTimesStamps.Duration@,HpTimesStamps.Duration@)">
            <summary>
            Compare two durations
            </summary>
            <param name="lhs">left hand comparand</param>
            <param name="rhs">right hand comparand</param>
            <returns>
            A positive number if <paramref name="lhs"/> succeeds <paramref name="rhs"/> in sort order.
            Zero if <paramref name="lhs"/> has the same position in the sort order as <paramref name="rhs"/>.
            A negative number if <paramref name="lhs"/> precedes <paramref name="rhs"/> in sort order.
            </returns>
        </member>
        <member name="M:HpTimesStamps.Duration.Multiply(System.Double)">
            <summary>
            Multiply this value by a specified factor
            </summary>
            <param name="factor">the factor</param>
            <returns>the product</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.Divide(System.Double)">
            <summary>
            Divide this value by a specified divisor
            </summary>
            <param name="divisor">the divisor</param>
            <returns>the product</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.Divide(HpTimesStamps.Duration)">
            <summary>
            Divide this value by another duration
            </summary>
            <param name="ts">the divisor</param>
            <returns>the quotient</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.op_Subtraction(HpTimesStamps.Duration@,HpTimesStamps.Duration@)">
            <summary>
            Subtract two durations
            </summary>
            <param name="t1">minuend</param>
            <param name="t2">subtrahend</param>
            <returns>difference</returns>
            <exception cref="T:System.OverflowException">Operation overflow</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.op_UnaryPlus(HpTimesStamps.Duration@)">
            <summary>
            Apply unary + operator
            </summary>
            <param name="t">operand</param>
            <returns>a value equal to <paramref name="t"/>/</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.op_Addition(HpTimesStamps.Duration@,HpTimesStamps.Duration@)">
            <summary>
            Add two addends
            </summary>
            <param name="t1">first addend</param>
            <param name="t2">second addend</param>
            <returns>sum</returns>
            <exception cref="T:System.OverflowException">Operation resulted in overflow</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.op_Multiply(System.Double,HpTimesStamps.Duration@)">
            <summary>
            Multiply a duration by a factor
            </summary>
            <param name="factor">the factor</param>
            <param name="timeSpan">the duration</param>
            <returns>the product</returns>
            <exception cref="T:System.OverflowException">Operation resulted in overflow.</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.op_Division(HpTimesStamps.Duration@,HpTimesStamps.Duration@)">
            <summary>
            Divide two durations
            </summary>
            <param name="t1">dividend</param>
            <param name="t2">divisor</param>
            <returns>quotient</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.op_Multiply(HpTimesStamps.Duration@,System.Double)">
            <summary>
            Multiply a duration 
            </summary>
            <param name="timeSpan">Duration factor</param>
            <param name="factor">factor</param>
            <returns>product</returns>
            <exception cref="T:System.ArgumentException"><paramref name="factor"/> was nan</exception>
            <exception cref="T:System.OverflowException">operation resulted in overflow</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.AbsoluteValue">
            <summary>
            Get the absolute value of this Duration
            </summary>
            <returns>the absolute value</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.Negate">
            <summary>
            Return the additive inverse of this value
            </summary>
            <returns>The additive inverse</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.Add(HpTimesStamps.Duration@)">
            <summary>
            Add another value to this one
            </summary>
            <param name="ts">value to add to this one</param>
            <returns>sum</returns>
            <exception cref="T:System.OverflowException">addition caused overflow</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.Subtract(HpTimesStamps.Duration@)">
            <summary>
            Subtract another value from this one
            </summary>
            <param name="ts">the subtrahend</param>
            <returns>the difference</returns>
            <exception cref="T:System.OverflowException">Result caused overflow.</exception>
        </member>
        <member name="M:HpTimesStamps.Duration.op_UnaryNegation(HpTimesStamps.Duration@)">
            <summary>
            Negate the duration
            </summary>
            <param name="t">The duration to negate</param>
            <returns>the additive inverse</returns>
        </member>
        <member name="M:HpTimesStamps.Duration.op_Division(HpTimesStamps.Duration@,System.Double)">
            <summary>
            Divide a duration by a divisor
            </summary>
            <param name="timeSpan">the dividend</param>
            <param name="divisor">divisor</param>
            <returns>quotient</returns>
            <exception cref="T:System.ArgumentException"><paramref name="divisor"/> was <see cref="F:System.Double.NaN"/>.</exception>
        </member>
        <member name="F:HpTimesStamps.Duration._ticks">
            <summary>
            Internal to allow fast direct access by other in this library.
            </summary>
        </member>
        <member name="T:HpTimesStamps.IMonotonicStampContext">
            <summary>
            The monotonic time stamp context should be implemented
            as a readonly struct
            </summary>
        </member>
        <member name="P:HpTimesStamps.IMonotonicStampContext.IsInvalid">
            <summary>
            True if the struct implementing this interface
            was not properly initialized.  Usually
            testing <see cref="P:HpTimesStamps.IMonotonicStampContext.ContextId"/> against
            the <see langword = "default"/> value of <see cref="T:System.Guid"/>
            is sufficient
            </summary>
        </member>
        <member name="P:HpTimesStamps.IMonotonicStampContext.ContextId">
            <summary>
            Unique id
            </summary>
        </member>
        <member name="P:HpTimesStamps.IMonotonicStampContext.AllTimestampsUtc">
            <summary>
            True if <see cref="P:HpTimesStamps.IMonotonicStampContext.UtcDateTimeBeginReference"/> equals
            <see cref="P:HpTimesStamps.IMonotonicStampContext.LocalTimeBeginReference"/>, false otherwise
            </summary>
        </member>
        <member name="P:HpTimesStamps.IMonotonicStampContext.UtcDateTimeBeginReference">
            <summary>
            The UTC neutral date time represented by
            <see cref="P:HpTimesStamps.IMonotonicStampContext.ReferenceTicks"/>.
            </summary>
        </member>
        <member name="P:HpTimesStamps.IMonotonicStampContext.LocalTimeBeginReference">
            <summary>
            The local time version of <see cref="P:HpTimesStamps.IMonotonicStampContext.UtcDateTimeBeginReference"/>.
            If <see cref="P:HpTimesStamps.IMonotonicStampContext.AllTimestampsUtc"/>, this value is equal to <see cref="P:HpTimesStamps.IMonotonicStampContext.UtcDateTimeBeginReference"/>.
            </summary>
        </member>
        <member name="P:HpTimesStamps.IMonotonicStampContext.ReferenceTicks">
            <summary>
            The number of clock ticks that equals <see cref="P:HpTimesStamps.IMonotonicStampContext.UtcDateTimeBeginReference"/>
            </summary>
        </member>
        <member name="P:HpTimesStamps.IMonotonicStampContext.TicksPerSecond">
            <summary>
            The number of clock ticks in one second
            </summary>
        </member>
        <member name="P:HpTimesStamps.IMonotonicStampContext.UtcLocalTimeOffset">
            <summary>
            Difference between <see cref="P:HpTimesStamps.IMonotonicStampContext.UtcDateTimeBeginReference"/> and <see cref="P:HpTimesStamps.IMonotonicStampContext.LocalTimeBeginReference"/>.
            </summary>
        </member>
        <member name="T:HpTimesStamps.ITimeStampUtil">
            <summary>
            Note that the times retrieved are not more accurate in ABSOLUTE terms.
            If <see cref="P:HpTimesStamps.ITimeStampUtil.IsHighPrecision"/> successive calls to get timestamp will
            be more accurate (with respect to each other, within the <see cref="P:HpTimesStamps.ITimeStampUtil.CalibrationWindow"/>).  
            </summary>
        </member>
        <member name="P:HpTimesStamps.ITimeStampUtil.StopWatchTicksPerSecond">
            <summary>
            Number of ticks per second by the stop watch's (and if <see cref="P:HpTimesStamps.ITimeStampUtil.IsHighPrecision"/>, the HPET's)
            reckoning
            </summary>
        </member>
        <member name="P:HpTimesStamps.ITimeStampUtil.DateTimeTicksPerSecond">
            <summary>
            Number of ticks per second by DateTime and TimeSpan's reckoning
            </summary>
        </member>
        <member name="P:HpTimesStamps.ITimeStampUtil.IsHighPrecision">
            <summary>
            Check whether high precision timestamps are possible, if not,
            might as well use DateTime.Now (unless you want hp wherever possible)
            </summary>
        </member>
        <member name="P:HpTimesStamps.ITimeStampUtil.CurrentLocalTimeStamp">
            <summary>
            Like DateTime.Now but based off of a reading from the high precision event timer
            and then converted into terms of the local time system
            </summary>
        </member>
        <member name="P:HpTimesStamps.ITimeStampUtil.CurrentUtcTimeStamp">
            <summary>
            Like DateTime.UtcNow, but based off of a reading from the high precision event timer
            then converted into terms of utc time system
            </summary>
        </member>
        <member name="P:HpTimesStamps.ITimeStampUtil.CalibrationWindow">
            <summary>
            The amount of time calibration lasts for.
            </summary>
        </member>
        <member name="P:HpTimesStamps.ITimeStampUtil.TimeSinceLastCalibration">
            <summary>
            Amount of time since last calibration.
            </summary>
        </member>
        <member name="P:HpTimesStamps.ITimeStampUtil.IsCalibrated">
            <summary>
            Whether the util is calibrated at present
            </summary>
        </member>
        <member name="M:HpTimesStamps.ITimeStampUtil.Calibrate">
            <summary>
            Manually force a calibration.  If not calibrated, upon call to
            <see cref="P:HpTimesStamps.ITimeStampUtil.CurrentLocalTimeStamp"/> or <see cref="P:HpTimesStamps.ITimeStampUtil.CurrentUtcTimeStamp"/> calibration will
            be performed before TimeStamp retrieval causing a delay.  If you want to avoid that,
            calling this will do the trick.
            </summary>
        </member>
        <member name="T:HpTimesStamps.LocklessLazyWriteOnceValue`1">
            <summary>
            
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:HpTimesStamps.LocklessLazyWriteOnceValue`1.IsSet">
            <summary>
            
            </summary>
        </member>
        <member name="M:HpTimesStamps.LocklessLazyWriteOnceValue`1.#ctor(System.Func{`0})">
            <summary>
            
            </summary>
            <param name="ctor"></param>
        </member>
        <member name="T:HpTimesStamps.MonotonicClockNotAvailableException">
            <summary>
            If the runtime / hardware does not have a monotonic clock available,  this exception is thrown.
            </summary>
        </member>
        <member name="M:HpTimesStamps.MonotonicClockNotAvailableException.#ctor">
            <summary>
            CTOR
            </summary>
        </member>
        <member name="T:HpTimesStamps.MonotonicStampContext">
            <summary>
            The implementation of <see cref="T:HpTimesStamps.IMonotonicStampContext"/> this library provides.
            </summary>
        </member>
        <member name="M:HpTimesStamps.MonotonicStampContext.CreateStampContext">
            <summary>
            Create a stamp context to serve as reference point for monotonic timestamps
            </summary>
            <returns>context value</returns>
        </member>
        <member name="P:HpTimesStamps.MonotonicStampContext.IsInvalid">
            <inheritdoc />
        </member>
        <member name="P:HpTimesStamps.MonotonicStampContext.ContextId">
            <inheritdoc />
        </member>
        <member name="P:HpTimesStamps.MonotonicStampContext.UtcDateTimeBeginReference">
            <inheritdoc />
        </member>
        <member name="P:HpTimesStamps.MonotonicStampContext.LocalTimeBeginReference">
            <inheritdoc />
        </member>
        <member name="P:HpTimesStamps.MonotonicStampContext.ReferenceTicks">
            <inheritdoc />
        </member>
        <member name="P:HpTimesStamps.MonotonicStampContext.TicksPerSecond">
            <inheritdoc />
        </member>
        <member name="P:HpTimesStamps.MonotonicStampContext.UtcLocalTimeOffset">
            <inheritdoc />
        </member>
        <member name="P:HpTimesStamps.MonotonicStampContext.AllTimestampsUtc">
            <inheritdoc />
        </member>
        <member name="M:HpTimesStamps.MonotonicStampContext.ToString">
            <inheritdoc />
        </member>
        <member name="M:HpTimesStamps.MonotonicStampContext.GetHashCode">
            <summary>
            Get a value-based hash code for this object
            </summary>
            <returns>a hash code</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicStampContext.Equals(System.Object)">
            <summary>
            Test another object to see whether it has the same value as this one.
            </summary>
            <param name="obj">The other object</param>
            <returns>True if the other object is of the same type as this one and has
            the same value as this one.  False otherwise.</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicStampContext.Equals(HpTimesStamps.MonotonicStampContext)">
            <summary>
            Test to see whether another value of this type has the same value as this one
            </summary>
            <param name="other">the other value</param>
            <returns>true if same value, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicStampContext.op_Equality(HpTimesStamps.MonotonicStampContext@,HpTimesStamps.MonotonicStampContext@)">
            <summary>
            Tests two stamp contexts for value equality
            </summary>
            <param name="lhs">left hand comparand</param>
            <param name="rhs">right hand comparand</param>
            <returns>true if they have the same value, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicStampContext.op_Inequality(HpTimesStamps.MonotonicStampContext@,HpTimesStamps.MonotonicStampContext@)">
            <summary>
            Tests two stamp contexts for value inequality
            </summary>
            <param name="lhs">left hand comparand</param>
            <param name="rhs">right hand comparand</param>
            <returns>true if they have the distinct values, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicStampContext.op_GreaterThan(HpTimesStamps.MonotonicStampContext@,HpTimesStamps.MonotonicStampContext@)">
            <summary>
            Test to see whether the left hand comparand is greater than (succeeds in sort order) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is greater than the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicStampContext.op_LessThan(HpTimesStamps.MonotonicStampContext@,HpTimesStamps.MonotonicStampContext@)">
            <summary>
            Test to see whether the left hand comparand is less than (precedes in sort order) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is less than the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicStampContext.op_GreaterThanOrEqual(HpTimesStamps.MonotonicStampContext@,HpTimesStamps.MonotonicStampContext@)">
            <summary>
            Test to see whether the left hand comparand is greater than (i.e. succeeds in sort-order) or equal to (i.e. is identical
            with and therefore holds sample place in sort order as) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is greater than or equal to the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicStampContext.op_LessThanOrEqual(HpTimesStamps.MonotonicStampContext@,HpTimesStamps.MonotonicStampContext@)">
            <summary>
            Test to see whether the left hand comparand is less than than (i.e. precedes in sort-order) or equal to (i.e. is identical
            with and therefore holds sample place in sort order as) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is less than or equal to the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicStampContext.CompareTo(HpTimesStamps.MonotonicStampContext)">
            <summary>
            Compare this context with another to establish the ordering between them
            </summary>
            <param name="other">the other</param>
            <returns>A negative number if the this value precedes the other value in the sort order.
            Zero if the this value is identical to the other value (and thus occupies same space in sort order).
            A positive number if this value succeeds the other value in sort order.</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicStampContext.Compare(HpTimesStamps.MonotonicStampContext@,HpTimesStamps.MonotonicStampContext@)">
            <summary>
            Compare two monotonic stamp contexts to establish their
            positions relative to each other in the sort order.
            </summary>
            <param name="lhs">left-hand comparand</param>
            <param name="rhs">Right-hand comparand</param>
            <returns>A negative number if the left-hand comparand precedes the right-hand comparand in the sort order.
            Zero if the left-hand comparand is identical to the right hand comparand (and thus occupies same space in sort order).
            A positive number if the left-hand comparand succeeds the right-hand comparand in sort order.</returns>
        </member>
        <member name="T:HpTimesStamps.MonotonicTimeStamp`1">
             <summary>
             A monotonic time stamp is a time stamp retrieved from a monotonic clock.
             Monotonic clocks have the property that for any two tick queries at T0 and T1
             OCCURRING IN PROCESS the ticks returned from query at T1 will always be greater
             than or equal to the ticks retrieved at query T0 (where T1 happens after T0).
            
             Using DateTime.Now as a timestamp source is problematic because it is based on a system /
             wall clock.  System / wall clocks can change forwards or backwards and thus can be problematic
             when used with the expectation DateTime t2 - DateTime t1 will give the time elapsed between t2 and t1
             (when DateTime t1 was recorded at T0 and DateTime t2 recorded at T1 where T1 was later in time than T0).
             In fact, the difference could even be negative -- saying that the later time was earlier:
                 Daylights savings adjustments
                 User adjustments to system clock
                 System clock synchronization with a reference clock
                 leap seconds, etc
            
             These timestamps:
                 1- are obtained from a source with a finer resolution that most DateTimes
                 2- are obtained from a source unaffected by adjustments to the system clock,
                    DST, leap seconds, etc.
             Advantages:
                 1- individually represented simply as ticks from a monotonic clock 
                 2- a reference date time is correlated with a reference number of ticks from the monotonic clock 
                 3- can be considered a reference date time and an offset period.
                 4- when subtracting one from another WITHIN PROCESS, will yield a timespan as accurate as the monotonic
                    clock supplying ticks
                 5- most useful when used to compare elapsed time between events 
             Disadvantages:
                 1- NEVER SERIALIZE OR SHARE OUTSIDE OF PROCESS
                 2- when interpreted as a date time, in the rare circumstances where the system clock changes, will be misleading
                 3- NEVER SERIALIZE OR SHARE OUTSIDE OF PROCESS -- useful for RUNNING program only.  You could convert to a date time
                    and serialize but may lose accuracy if the system clock and the monotonic clock are no longer in lockstep.
             </summary>
             <typeparam name="TStampContext">The common context used by all stamps parameterized with this type</typeparam>
             <remarks>DO NOT USE ACROSS PROCESSES!  DO NOT SERIALIZE!  NOT FOR ARCHIVE!</remarks>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.CreateFromRefTicks(System.Int64)">
            <summary>
            Create a monotonic timestamp from a tick count retrieved from the reference clock.
            </summary>
            <param name="referenceTicks">the tick count</param>
            <returns>a monotonic timestamp</returns>
        </member>
        <member name="P:HpTimesStamps.MonotonicTimeStamp`1.Context">
            <summary>
            The stamp context shared by all timestamps parameterized by <typeparamref name="TStampContext"/>.
            </summary>
        </member>
        <member name="P:HpTimesStamps.MonotonicTimeStamp`1.Value">
            <summary>
            Retrieve the data in the most honest/least problematic (though perhaps a little inconvenient)
            format available:
                1- The UTC reference date time
                2- the amount of time that elapsed between the utc reference time
                   and the recording of the stamp
                3- the difference between the local reference time and utc reference time
            </summary>
        </member>
        <member name="P:HpTimesStamps.MonotonicTimeStamp`1.ElapsedSinceUtcReference">
            <summary>
            Amount of time elapsed since the Utc Reference Time between the timestamp being recorded and the utc reference time 
            </summary>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.#ctor(System.Int64)">
            <summary>
            Private CTOR
            </summary>
            <param name="stopwatchTicks"></param>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.ToLocalDateTime">
            <summary>
            Convert the timestamp to a local date time.  If the system clock and the reference
            monotonic clock are out of sync (drift or adjustments made to system clock or time -- user edit,
            syncing of system clock, daylight savings adjustments, leap seconds, etc), may not be accurate.
            </summary>
            <returns>a datetime</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.ToUtcDateTime">
            <summary>
            Convert the timestamp to a utc date time.  If the system clock and the reference
            monotonic clock are out of sync (drift or adjustments made to system clock or time -- user edit,
            syncing of system clock, leap seconds, etc), may not be accurate.
            </summary>
            <returns>a date-time</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.op_Equality(HpTimesStamps.MonotonicTimeStamp{`0},HpTimesStamps.MonotonicTimeStamp{`0})">
            <summary>
            Tests two stamps for value equality
            </summary>
            <param name="lhs">left hand comparand</param>
            <param name="rhs">right hand comparand</param>
            <returns>true if they have the same value, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.op_Inequality(HpTimesStamps.MonotonicTimeStamp{`0},HpTimesStamps.MonotonicTimeStamp{`0})">
            <summary>
            Tests two stamps for value inequality
            </summary>
            <param name="lhs">left hand comparand</param>
            <param name="rhs">right hand comparand</param>
            <returns>true if they have the distinct values, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.op_GreaterThan(HpTimesStamps.MonotonicTimeStamp{`0},HpTimesStamps.MonotonicTimeStamp{`0})">
            <summary>
            Test to see whether the left hand comparand is greater than (succeeds in sort order) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is greater than the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.op_LessThan(HpTimesStamps.MonotonicTimeStamp{`0},HpTimesStamps.MonotonicTimeStamp{`0})">
            <summary>
            Test to see whether the left hand comparand is less than (precedes in sort order) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is less than the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.op_GreaterThanOrEqual(HpTimesStamps.MonotonicTimeStamp{`0},HpTimesStamps.MonotonicTimeStamp{`0})">
            <summary>
            Test to see whether the left hand comparand is greater than (i.e. succeeds in sort-order) or equal to (i.e. is identical
            with and therefore holds sample place in sort order as) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is greater than or equal to the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.op_LessThanOrEqual(HpTimesStamps.MonotonicTimeStamp{`0},HpTimesStamps.MonotonicTimeStamp{`0})">
            <summary>
            Test to see whether the left hand comparand is less than than (i.e. precedes in sort-order) or equal to (i.e. is identical
            with and therefore holds sample place in sort order as) the right hand comparand.
            </summary>
            <param name="lhs">The left hand comparand</param>
            <param name="rhs">the right hand comparand</param>
            <returns>true if the left hand comparand is less than or equal to the right hand comparand, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.GetHashCode">
            <summary>
            Get a value-based hash code for this object
            </summary>
            <returns>a hash code</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.Equals(System.Object)">
            <summary>
            Test another object to see whether it has the same value as this one.
            </summary>
            <param name="other">The other object</param>
            <returns>True if the other object is of the same type as this one and has
            the same value as this one.  False otherwise.</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.Equals(HpTimesStamps.MonotonicTimeStamp{`0})">
            <summary>
            Test to see whether another value of this type has the same value as this one
            </summary>
            <param name="other">the other value</param>
            <returns>true if same value, false otherwise</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.CompareTo(HpTimesStamps.MonotonicTimeStamp{`0})">
            <summary>
            Compare this stamp with another to establish the ordering between them
            </summary>
            <param name="other">the other</param>
            <returns>A negative number if the this value precedes the other value in the sort order.
            Zero if the this value is identical to the other value (and thus occupies same space in sort order).
            A positive number if this value succeeds the other value in sort order.</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.op_Addition(HpTimesStamps.MonotonicTimeStamp{`0},System.TimeSpan)">
            <summary>
            Add a stamp and timespan together yielding a stamp
            </summary>
            <param name="lhs">left hand stamp operand</param>
            <param name="rhs">right hand timespan operand</param>
            <returns>a stamp that is the result of adding a stamp and timespan together</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.op_Addition(System.TimeSpan,HpTimesStamps.MonotonicTimeStamp{`0})">
            <summary>
            Add a stamp and timespan together yielding a stamp
            </summary>
            <param name="lhs">left hand timespan operand</param>
            <param name="rhs">right hand stamp operand</param>
            <returns>a stamp that is the result of adding a stamp and timespan together</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.op_Subtraction(HpTimesStamps.MonotonicTimeStamp{`0},HpTimesStamps.MonotonicTimeStamp{`0})">
            <summary>
            Subtract the right hand stamp from the left hand comparand, yielding
            the time elapsed between the two.
            </summary>
            <param name="lhs">the left hand operand</param>
            <param name="rhs">the right and operand</param>
            <returns>the amount of time elapsed between the operands</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.op_Subtraction(HpTimesStamps.MonotonicTimeStamp{`0},System.TimeSpan)">
            <summary>
            Subtract a timespan from a stamp yielding a stamp
            </summary>
            <param name="lhs">the stamp minuend</param>
            <param name="rhs">the timespan subtrahend</param>
            <returns>A stamp difference</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStamp`1.ToString">
            <summary>
            Get a string representation of this value
            </summary>
            <returns>a string representation.</returns>
            <remarks>Will be printed as a local DateTime represented in ISO format.  If
            there has been significant drift between monotonic clock and system clock
            or if the system clock has changed due to user adjustments, synchro with clock server,
            daylight savings time, leap seconds ... may be inaccurate or misleading.</remarks>
        </member>
        <member name="T:HpTimesStamps.MonotonicTimeStampUtil`1">
            <summary>
            A utility designed to create monotonic timestamps
            </summary>
            <typeparam name="TStampContext">The type of context this utility uses to create timestamps.</typeparam>
        </member>
        <member name="P:HpTimesStamps.MonotonicTimeStampUtil`1.StampNow">
            <summary>
            Retrieve a monotonic timestamp recorded right now.
            </summary>
        </member>
        <member name="P:HpTimesStamps.MonotonicTimeStampUtil`1.Now">
            <summary>
            Get a monotonic timestamp as a local date time.
            </summary>
            <remarks>
            If the system clock and the reference
            monotonic clock are out of sync (drift or adjustments made to system clock or time -- user edit,
            syncing of system clock, daylight savings adjustments, leap seconds, etc), may not be accurate
            in an ABSOLUTE sense.
            Subtracting/Comparing with another datetime obtained using this property
            IN PROCESS should be accurate.
            </remarks>
        </member>
        <member name="P:HpTimesStamps.MonotonicTimeStampUtil`1.UtcNow">
            <summary>
            Get a monotonic timestamp as a utc date time.
            </summary>
            <remarks>
            If the system clock and the reference
            monotonic clock are out of sync (drift or adjustments made to system clock or time -- user edit,
            syncing of system clock, leap seconds, etc), may not be accurate
            in an ABSOLUTE sense.
            Subtracting/Comparing with another datetime obtained using this property IN PROCESS
            should be accurate.
            </remarks>
        </member>
        <member name="P:HpTimesStamps.MonotonicTimeStampUtil`1.StampContext">
            <summary>
            The stamp context available by readonly-reference.  Once set for a particular instantiation of <typeparamref name="TStampContext"/>
            is immutable.  This value can be set by:
                - Accessing this property for the first time (will be set to <see cref="F:HpTimesStamps.MonotonicTimeStampUtil`1.TheStampContext"/>) OR
                - Calling <see cref="M:HpTimesStamps.MonotonicTimeStampUtil`1.TrySupplyNonDefaultContext(`0@)"/> or <see cref="M:HpTimesStamps.MonotonicTimeStampUtil`1.SupplyNonDefaultContextOrThrow(`0@)"/> (assuming call is successful).
                  For these calls to BE successful, must be called before first time this property is accessed.
            </summary>
        </member>
        <member name="P:HpTimesStamps.MonotonicTimeStampUtil`1.IsContextSet">
            <summary>
            True if <see cref="P:HpTimesStamps.MonotonicTimeStampUtil`1.StampContext"/> has been initialized, false otherwise.
            Initialization is caused by access to the <see cref="P:HpTimesStamps.MonotonicTimeStampUtil`1.StampContext"/> property or
            successful calls to <see cref="M:HpTimesStamps.MonotonicTimeStampUtil`1.TrySupplyNonDefaultContext(`0@)"/> or <see cref="M:HpTimesStamps.MonotonicTimeStampUtil`1.SupplyNonDefaultContextOrThrow(`0@)"/>.
            </summary>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStampUtil`1.TrySupplyNonDefaultContext(`0@)">
            <summary>
            Attempt to set the stamp context to the provided value
            </summary>
            <param name="context">The context</param>
            <returns>True for success, false for failure</returns>
        </member>
        <member name="M:HpTimesStamps.MonotonicTimeStampUtil`1.SupplyNonDefaultContextOrThrow(`0@)">
            <summary>
            Supply a non-default context object or throw an exception
            </summary>
            <param name="context">the non-default context</param>
            <exception cref="T:System.ArgumentException">The supplied context is invalid.</exception>
            <exception cref="T:System.InvalidOperationException">The context has already been set.</exception>
        </member>
        <member name="T:HpTimesStamps.TimeStampSource">
            <summary>
            Calibration is PER THREAD.  Calls are therefore thread-safe, but calibration may need to be done
            on each thread using this resource.
            </summary>
            <seealso cref="T:HpTimesStamps.TimeStampUtil">for more information</seealso>
        </member>
        <member name="P:HpTimesStamps.TimeStampSource.IsHighPrecision">
            <summary>
            True if high precision timestamps are used, false otherwise.
            </summary>
        </member>
        <member name="P:HpTimesStamps.TimeStampSource.UtcNow">
            <summary>
            High precision (if available) Utc timestamp
            </summary>
        </member>
        <member name="P:HpTimesStamps.TimeStampSource.Now">
            <summary>
            High precision (if available) timestamp available here
            </summary>
        </member>
        <member name="P:HpTimesStamps.TimeStampSource.NeedsCalibration">
            <summary>
            True if calibration is needed on THIS thread, false otherwise
            </summary>
        </member>
        <member name="P:HpTimesStamps.TimeStampSource.TimeSinceCalibration">
            <summary>
            How long has it been since calibration (on THIS thread)
            </summary>
        </member>
        <member name="M:HpTimesStamps.TimeStampSource.Calibrate">
            <summary>
            Perform calibration now for THIS thread
            </summary>
        </member>
        <member name="T:HpTimesStamps.TimeStampUtil">
             <summary>
             This struct is used in <see cref="T:HpTimesStamps.TimeStampSource"/> to provide high precision timestamps on a per thread basis.
             These timestamps have exactly the same format as timestamps retrieved by <see cref="P:System.DateTime.Now"/>, which
             corresponds to <see cref="P:HpTimesStamps.TimeStampUtil.CurrentLocalTimeStamp"/> herein and to <see cref="P:HpTimesStamps.TimeStampSource.Now"/> and <see cref="P:System.DateTime.UtcNow"/>,
             which corresponds to <see cref="P:HpTimesStamps.TimeStampUtil.CurrentUtcTimeStamp"/> herein and to <see cref="P:HpTimesStamps.TimeStampSource.UtcNow"/>.
            
             Please note that this (where hardware makes it possible) provides high PRECISION timestamps, not necessarily high ACCURACY
             timestamps.  DateTime.Now or .UtcNow may actually provide timestamps that are more accurate in terms of lack
             of deviation from official times.  These timestamps, however, should be -- on a single thread at least -- more accurate with respect
             to successively retrieved timestamps within a rather short period of time because they, where possible, make use of the hardware's high precision
             event timer.
            
             Calibration occurs on a per-thread basis by retrieving establishing an offset between the ticks value of DateTime.Now and the
             high precision event timer.  It then converts subsequent readings from the high precision timer back into DateTime format.
            
             As the time since <see cref="P:HpTimesStamps.TimeStampUtil.TimeSinceLastCalibration"/> increases, the high precision timer becomes LESS ACCURATE vis-a-vis
             "absolute" real time, but remains accurate with respect to the elapsed time the last time stamp was retrieved, a short time ago.
             Every time <see cref="P:HpTimesStamps.TimeStampUtil.TimeSinceLastCalibration"/> elapses, the next time stamp retrieval will recalibrate, causing retrieval to
             take slightly longer.  You can call <see cref="M:HpTimesStamps.TimeStampUtil.Calibrate"/> manually to do this yourself immediately before retrieving timestamps.
            
             The use-case for these timestamps is when you need timestamps that are approximately accurate vis-a-vis the system clock but also
             occasionally use them to measure elapsed time between events that occur in fractions of a millisecond.  In the latter use, they should
             be far better suited than DateTime.Now.  They may be somewhat less accurate than DateTime.Now with respect to the absolute, official
             UTC time, but remain accurate enough for many such purposes.
            
             Note that this library may malfunction until recalibration if the system clock changes ... at least until recalibration occurs.
            
             This struct is a time stamp util.  It should be accessed via TimeStampSource.
             If you wish to make your own time stamp util struct, make sure it has all the same public
             methods, operators and properties that this struct has.  Then alter the alias at the top of
             <see cref="T:HpTimesStamps.TimeStampSource"/>file to use yours and then recompile.  I do not recommend using interface
             as that introduces unneeded delay.
            
             The time stamp state is all thread local.  This means that calibration is done on a per thread basis.
             
             </summary>
        </member>
        <member name="P:HpTimesStamps.TimeStampUtil.IsHighPrecision">
            <summary>
            True if a high precision event timer is available, false otherwise
            </summary>
        </member>
        <member name="P:HpTimesStamps.TimeStampUtil.IsCalibrated">
            <summary>
            True if the util has a current calibration.  <seealso cref="P:HpTimesStamps.TimeStampUtil.CalibrationWindow"/> for how long
            calibration lasts before becoming considered stale.
            </summary>
        </member>
        <member name="P:HpTimesStamps.TimeStampUtil.StopWatchTicksPerSecond">
            <summary>
            How many high precision ticks per second are there?
            </summary>
        </member>
        <member name="P:HpTimesStamps.TimeStampUtil.DateTimeTicksPerSecond">
            <summary>
            How many date time ticks per second are there?
            </summary>
        </member>
        <member name="P:HpTimesStamps.TimeStampUtil.TimeSinceLastCalibration">
            <summary>
            How much time has elapsed since last calibration (per thread)
            </summary>
        </member>
        <member name="P:HpTimesStamps.TimeStampUtil.CalibrationWindow">
            <summary>
            How much time may elapse before calibration becomes considered stale.
            </summary>
        </member>
        <member name="P:HpTimesStamps.TimeStampUtil.CurrentUtcTimeStamp">
            <summary>
            Not yet tested; probably will not work.
            todo fixit make it work
            </summary>
        </member>
        <member name="P:HpTimesStamps.TimeStampUtil.CurrentLocalTimeStamp">
            <summary>
            Analog for <seealso cref="P:System.DateTime.Now"/> uses higher precision
            </summary>
        </member>
        <member name="M:HpTimesStamps.TimeStampUtil.Calibrate">
            <summary>
            Perform calibration
            </summary>
        </member>
        <member name="M:HpTimesStamps.TimeStampUtil.op_Equality(HpTimesStamps.TimeStampUtil,HpTimesStamps.TimeStampUtil)">
            <summary>
            Always true ... all state is thread local and static
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:HpTimesStamps.TimeStampUtil.op_Inequality(HpTimesStamps.TimeStampUtil,HpTimesStamps.TimeStampUtil)">
            <summary>
            Always false, all state is thread local and static
            </summary>
            <returns>false</returns>
        </member>
        <member name="M:HpTimesStamps.TimeStampUtil.Equals(HpTimesStamps.TimeStampUtil)">
            <summary>
            Always true ... all state is thread local and static
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:HpTimesStamps.TimeStampUtil.GetHashCode">
            <summary>
            397 is always the hash code.  All instances are considered equal
            </summary>
            <returns>397</returns>
        </member>
        <member name="M:HpTimesStamps.TimeStampUtil.Equals(HpTimesStamps.ITimeStampUtil)">
            <summary>
            True if <paramref name="other"/> is a not null and is of type <see cref="T:HpTimesStamps.TimeStampUtil"/>,
            false otherwise.
            </summary>
            <param name="other">Another object implementing this interface</param>
            <returns>True if <paramref name="other"/> is a not null and is of type <see cref="T:HpTimesStamps.TimeStampUtil"/>,
            false otherwise.</returns>
        </member>
        <member name="M:HpTimesStamps.TimeStampUtil.Equals(System.Object)">
            <summary>
            True if <paramref name="other"/> is a not null and is of type <see cref="T:HpTimesStamps.TimeStampUtil"/>,
            false otherwise.
            </summary>
            <param name="other">Another object implementing this interface</param>
            <returns>True if <paramref name="other"/> is a not null and is of type <see cref="T:HpTimesStamps.TimeStampUtil"/>,
            false otherwise.</returns>
        </member>
    </members>
</doc>
